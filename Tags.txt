<br/> - разрыв строки (Shift+Enter)
<p></p> - параграф, абзац (Enter)
<hr/> - горизонтальная линия (horizontal rule)
<span></span> - строчный элемент (выделяет выделенную строку без переноса)
<b> - Жирный текст
<strong> - Важный текст
font-weight: bold;
<i> - текст Курсив (наклонный)
<em> - текст Акцентирует внимание (наклонный)
<mark> - Маркированный текст
<small> - Небольшой текст
<del> - Удаленный (зачеркнутый) текст
<ins> - Вставленный (добавить) текст
<sub> - Подстрочный текст
<sup> - Надстрочный текст

<p contenteditable="true"> - делает параграф редактируемым

lorem20 - набор рыбьего текста 

<a href="">Наименование ссылки</a> - ссылка 
<a href="" target="_blank"> </a> - ссылка в новой вкладке
<img src="" alt=""> - тег для вставки URL или локального пути изображения. "alt" используется для написания текстового объяснения, в случае если фото будет недоступно
<_ target="_blank"> - открытие в новой вкладке
<a href="https://webref.ru"><img src="image/shark.jpg" alt=""></a> - ссылка в изображении

<ol></ol> - упорядоченная оболочка для пунктов списка
<ul></ul> - неупорядоченный, dots список 
<ol/<ul type="I/square"> Для изменения нумерации используют "type" 
<li></li> - сам список (пишется внутри <ul></ul> или <ol></ol>)

<li value="3"> -ставит значение 3 для нумерации строки
style= "list-style-type: disc/circle/square/decimal/georgian/trad-chinese-informal/kannada; "

ul>li{Элемент $}*5 - Появится 5 строк с наименованием "Элемент".При добавлении "$", появится нумерация   

<table></table> - оболочка для тегов таблицы
<thead></thead> - заголовок таблицы 
(столбцы именуются как <th></th>, а не как <td></td>. Но вкладываются все равно в <tr> <th></th> </tr>)
<tr></tr> - строка таблицы (table rool)
<th></th> - столбцы заголовка таблицы
<tbody></tbody> - основное тело таблицы
<tr></tr> - строка таблицы (table rool)
<td></td> - столбцы в теле таблицы (внутри тега <tr></tr>) (table data)

<form></form> - поле для ввода
<label for="логин">Логин</label> -  текст перед полем ввода. Тег "for" связывается с тегом "id" и при нажатии на текст выделяется форма.
<input type="text/password/email/number/range/date/color/message/" id="логин"> - что будет вводиться в поле ввода.

<section id="sex">
    <option value="Мужчина">м</option>
    <option value="Женщина">ж</option>
</section> - выпадающий из прошлого список

<value=""> - атрибут тега, определяет что будет написано
<id=""> и <class=""> - "id" не должно повторяться, "class" может и используется для стилистики
<div></div> - блочный элемент (выделяет и переносит абзацом)
<header>/<footer>/<nav>/<article>/<section (группа для article)>/<aside (для меню слева-справа)> - это все замена <div> для правильной индексации и нормализации поиска сайта

<figure>
   <img src="" alt="">
   <figcaption>Подпись</figcaption> - связывает подпись с картинкой
</figure> 
<details>
   <summary></summary> - Описание и краткое заглавие выпадающего описания
</details>

_______________________________
CSS
   h1       {color: red}
-селектор {свойство: значение}
-свойство: функции (значение);
.class > p - обращение только к детям класса (не учитывая детей детей)
---------------------------------------------------------
font-family - выбор шрифта (Roboto,Times..)
font-size - размер текста
font-weight - толщина начертание шрифта (аналог <strong>)
text-transform: uppercase - заглавный шрифт
---------------------------------------------------------
width= "150" - устанавливает ширину элемента (ширину области)
word-spacing - расстояние между словами
letter-spacing - расстояние между символами
line-height - межстрочный интервал
text-decoration: underline; - подчеркивания, зачеркивания, none
<del></del> -зачеркнутый текст или (представляет диапазон текста, который был удалён из документа)
<ins></ins> - подчеркивание или (показывает что было добавлено в код)
opacity: 0.4 - непрозрачность элемента
---------------------------------------------------------
#ff0000 - красный; color: #00ff00 зеленый; color: #00ff00 синий;
color: rgba(0, 255, 0, 0.2) - цвета и прозрачность
-Дизайн цвета можно копировать с браузера с помощью пипетки из "Исследовать элемент"
---------------------------------------------------------
-CSS код можно писать как в  HTML в <head><style></style></head>
 Можно писать инлайн <header style="color: black;"></header>
 Можно писать так же отдельно в css файле: <link rel="stylesheet" href="Index.css0">
---------------------------------------------------------
padding: 0px 20px 0px 20px - можно написать сразу для 4х сторон. Отсчёт идёт по часовой стрелке.
padding - внутренние отступы (внутри рамки)
margine - внешние отступы (за рамкой)
margin: auto; - выравнивание по центру 
bottom - подвал/низ
top - верх
---------------------------------------------------------
* {} - селектор задает значение всему на странице
#id {} - стилизация через ID: #id {}
.card p {} -для обращения к безликому(повторяющемуся в др местах) дочернему тегу через родительский указываем путь: .card p {}
@import url() - Импорт шрифта
div p - выбор всех элементов p внутри элемента div
---------------------------------------------------------
filter: blur(2px)
filter: grayscale (0%) - сепия
filter: opacity (100%) - непрозрачность
filter: saturate (100%) - насыщенность 
filter: contrast (100%) - контрастность
background: linear-gradient ( 45deg, blue, lightGreen) - градиент
cursor:pointer; - изменение курсора при наведении
---------------------------------------------------------
background-image: url("img/whistle.svg"); - выставление бэкграунд фото
background-repeat: no-repeat; - не размазывать фон (иконки) по всему блоку
background-position: center top; - местоположение бэкграунд изображения (может выступать иконкой, а не фоном сайта)
background-position: right 35% bottom 45%;
background-size: - размер изображения
---------------------------------------------------------
list-style: none или url('/media/examples/rocket.svg'); - что будет показываться в пунктах(точках) списка
---------------------------------------------------------
.cards a:hover {} - интерактивность при наведении на элемент, меняет цвет/размер шрифта итд 
transition: all .2s; - анимация увеличения для селектора (например для ссылки при наведении)
.table:nth-child(odd/even/1/2/3..) - выделение столбцов таблицы
---------------------------------------------------------
Flex
---------------------------------------------------------
Используется для родительского элемента:
<div class="container"><div></div></div>

display: flex; - создаёт флекс контейнер 
flex-direction: row/column; - элементы в строку/ в колонке

.container { justify-content: center; } - установка элемента по центру
justify-content: space-around; - равномерное распределение элементов по контейнеру (space-around/space-between/center/start/end)
---------------------------------------------------------
_______________________________
JavaScript 
JS - регистрозависимый язык
---------------------------------------------------------
Функция isNaN() возвращает true, если значение не число, равно NaN (Not-a-Number), и false, если нет.
---------------------------------------------------------
== 	равно
=== 	равное значение и равный тип
!= 	не равный
---------------------------------------------------------
unshift - Добавление новых элементов в начало массива
var fruits = ["Банан", "Апельсин", "Яблоко", "Манго"];
fruits.unshift("Lemon","Pineapple");
---------------------------------------------------------
Math.max([x[, y[, …]]])- Возвращает наибольшее число из своих аргументов.
---------------------------------------------------------
//// Циклы
---------------------------------------------------------
// Будь внимателен в Циклах и Массивах
* со знаками <= >= < > 
* с Мутациями массива
-------------------
Если не сходится счет цикла с индексами массива, то возможно дело в знаках или в slice(start, end) – создаёт новый массив, копируя в него элементы с позиции start до end (не включая end). 
Дело может быть так же в методах массивов: С мутацией или без 

// Вот пример когда создание переменной с хранением в ней длинны массива может помочь избежать неправильного подсчета итераций и индексов при мутации массива с использованием на примере shift(). 

const peopleWaiting = [
   "Кристина",
   "Олег",
   "Кирилл",
   "Мария",
   "Светлана",
   "Артем",
   "Глеб"
];

let numberGotParcel = peopleWaiting.length;

for (let i = 0; i < numberGotParcel; i++) {
   console.log('numberGotParcel', numberGotParcel); // 7
   console.log('peopleWaiting.length', peopleWaiting.length); // 7 => 1

   const visitorLeaveName = peopleWaiting.shift();
   console.log(`${visitorLeaveName} получил(а) посылку. В очереди осталось ${peopleWaiting.length} человек`);
};

-------------------
for (начало; условие; шаг) {
  // ... тело цикла ...
}
for (let i = 0; i < 3; i++) { 
   // выведет 0, затем 1, затем 2
  alert(i);
}
---------------------------------------------------------
Чтобы вывести объединить текстовую строку и переменную является знак «+». Чтобы сообщить о том, что здесь закончился текст и начинается переменная Javascript, нужно открыть и закрыть кавычки.
alert( "Привет " + name + "!");
---------------------------------------------------------
<script defer src="js/vendor/jquery.js"></script>
async - выполнение скриптов по мере возможности, "рандомно"
defer - выполнение в строгой последовательности их размещения
---------------------------------------------------------
Math.floor() - округление вниз. Округляет аргумент до ближайшего меньшего целого.
---------------------------------------------------------
querySelector - "найди и принеси элемент" селектор запросов (en/ru)
document.querySelector('селектор');
document.querySelector('.page'); - js ищет на странице элемент с классом "page"
---------------------------------------------------------
Для добавления js в html, <script></script> добавляется перед </body>
Для подключения js к html необходимо ввести в конце <body> <script src="index.js"></script> </body>
---------------------------------------------------------
Тестирование с помощью консоли (вывод в консоль):
console.log(document.querySelector('.page'));
console.log - обращение к консоли
(document. ___ ) - "документ" поиск по данному файлу 
---------------------------------------------------------
/// classList.remove() - удаление класса 
-------------------
элемент.classList.remove('класс');
document.querySelector('.page').classList.remove('light-theme');

Сначала ищем селектор, во втором моменте "." не ставится, тк js знает что это класс

// Or

найденный_класс.remove();

    document.querySelector('.cookie-consent').remove();
---------
    const cookieConsentButton = document.querySelector('.cookie-consent__button');

    cookieConsentButton.addEventListener('click', function() {
        document.querySelector('.cookie-consent').remove();
    });
---------------------------------------------------------
/// classList.add - добавление класса 
элемент.classList.add('класс');
---------------------------------------------------------
Переменная — это способ сохранить данные, дав им понятное название (ярлык с файлами).
Константа - почти тоже самое что и переменная, только значение которой нельзя менять
---------------------------------------------------------
let - с помощью него можно создать (объявить) переменную. 
let: - "пусть/допустим" за которым следует имя для вашей переменной. 
Чтобы задать несколько значений let 
let numbers = [10, 4, 100, -5, 54, 2]; - массив

У переменных после их наименования с помощью "let" должно быть присвоено значение.
" = " - с помощью знака равенства присваиваем значение переменной
let variableName = 'Я значение переменной!';

let header = document.querySelector('header'); - при вводе переменной "header", JS выполняет функцию поиска по документу селектора header
---------------------------------------------------------
Условия / условные выравнивания (Conditionals) - it/else/else if 
---------------------------------------------------------
События (Events) - это действия, которые происходят в браузере, например, нажатие кнопки или загрузка страницы или воспроизведение видео, в ответ на которые мы можем запускать блоки кода.
Конструкции прослушивающие события - прослушиватели событий
Блоки кода выполняемы в ответ на срабатывание события - обработчики событий
---------------------------------------------------------
Циклы (Loops)

for - для / of - из

const fruits = ['apples', 'bananas', 'cherries'];
for (const fruit of fruits) {
  console.log(fruit);
}
Данный цикл будет поочередно выводить значения массива константы "fruits"
Строка for (const fruit of fruits) говорит:
1.Получи первый элемент из fruits.
2.Установи переменную fruit для этого элемента, затем запусти код между скобками {}.
3.Получи следующий элемент из fruits и повторяй, пока не дойдешь до конца.
---------------------------------------------------------
Массив — это набор элементов
Строка const fruit = ['apples', 'bananas', 'cherries']; создает массив.
---------------------------------------------------------
focus() - 
guessField.focus(); помещает курсор в текстовое поле при загрузки страницы 
---------------------------------------------------------
alert() - выводит модальное окно на странице
const years = prompt('Сколько вам лет?', 100);
alert('Вам ' + years + ' лет!')

prompt() - выводит окно с строкой заполнения и его возможным заполнением('Наименование окна','Запись в строке заполнения') 
Сохранить в переменную: const userName = prompt('Как вас зовут?');

confirm() - диалоговое окно с сообщением и кнопками выбора "cancel" - false, "ok" - true.
---------------------------------------------------------
Чтобы вывести в консоль в одну строку несолько параметров:
console.log(`${myInfoText[0]} ${myInfoText[441]}`)
---------------------------------------------------------
Определяем переменную let: 
let name = 'Petr the pig';
Переопределяем и выводим для проверки в консоль:
name = 'Nastya'
console.log("Имя было изменено", name);
Или можно переопределить на другую переменную:
ageOfPerson2 = ageOfPerson1;

Определяем переменную const: 
const programmingLanguage = 'JavaScript';
Константа не переопределяется и выходит ошибка:
programmingLanguage = 'Java'
console.log(Java);
---------------------------------------------------------
В JS 8 типов данных:
- String (строка)
- Number - число
- Boolean - (логический) оперирует только trye/false
- Null - пустое значение или значение неизвестно 
- Undefined - переменная была объявлена, но значение ей не присвоено.
let x;
console.log(x);
(оставь этот вывод значения системе, используй null)
- Object - сложный тип данных, объединяющий несколько параметров
const car = {
   name: "Toyota Corolla",
   year: 2017,
   isNew: false,
   owner: null
 }
//  Обратиться к свойству Объекта:
 console.log(car.name);
- Symbol - нужен для создания уникальных ключей объекта (невозможно преобразовать в number)
const id = Symbol('id');
console.log(id);
- BigInt - большое число (больше, чем (2⁵³-1), т.е. 9007199254740991).
Для создания переменной этого типа нужно поставить букву n в конце числа: 
let bigNumber = 123456789n;
Число гугол может быть записано как 1e9 (1 * 10^9).
---------------------------------------------------------
// Как определить тип данных? (например что это строка)
typeof('') или typeof ''
console.log(typeof 'Maxim')
// Проверка на тип значения = 'число'
   const value = 2   
   if (typeof value === 'number') {
      //it's a number
   }
---------------------------------------------------------
// Явное преобразование к строке:
String(_переменная_)
const age = 22;
console.log('string age:', age, typeof String(age)); 

// Явное преобразование к числу:
Number(_переменная_)
'Hello' - выведет NaN (not a number)
'1 2' - выведет NaN (not a number)
let question2 = Number(prompt('Сколько будет 2 * 2?'))

// Явное преобразование к Boolean:
Большинство переменных выводится "true"
null, Undefined, NaN, 0, '' - выводится false ('' - пустая строчка)
'0' - строка, выдаст true
---------------------------------------------------------
// Конкатенация - операция соединения строк (например строк, строк строки, поиск нужных символов и фраз)
const name = 'Denis';
const specialization = 'Novice-developer';

// Конкатенация 3 способа:

const allInfo1 = name + ' ' + specialization;
console.log(allInfo1);

const allInfo2 = `${name} ${specialization}`
console.log(allInfo2);

let allInfo3 = name + ' ';
allInfo3 += specialization;
console.log(allInfo3);

"Hello".concat(" T", "p", "r", "o", "g", "e", "r"); // "Hello Tproger"
---------------------------------------------------------
// Узнать длину строки (length)
const programmingLanguage = 'JavaScript';
console.log(programmingLanguage.length); // 10

// Получение индекса (буквы) строки
   Отсчет идет с 0
console.log(programmingLanguage[4]); // S
console.log(programmingLanguage[44]); // undefined
Или с помощью команды .charAt(0)
   С помощью этого НЕЛЬЗЯ поменять символ 
programmingLanguage[4] = 's'; (не сработает)
   Получаем последний символ
alert( str[str.length - 1] ); // o
---------------------------------------------------------
// toUpperCase, toLowerCase - изменяет на ЗАГЛАВНЫЕ и строчные 
   const animal = 'Lion';
   console.log('upper', animal.toUpperCase());
   console.log('lower', animal.toLowerCase());
   console.log(animal); - не изменяет само значение, а создает новое с заглавными или строчными

Слово с заглавной буквы:
   const publication = "freeCodeCamp";
   const FreeCodeCamp = publication[0].toUpperCase() + publication.substring(1);

   console.log('freeCodeCamp toUpperCase:', FreeCodeCamp);

Несколько слов с заглавной буквы:
   const mySentence = "freeCodeCamp is an awesome resource";
   const words = mySentence.split(" ");
   words.map((word) => { 
      return word[0].toUpperCase() + word.substring(1); 
   }).join(" ");
---------------------------------------------------------
// slice, substring - Если нужно получить символы между определенными индексами
const programmingLanguage1 = 'JavaScript';
console.log('slice', programmingLanguage1.slice(1, 5)); // avaS
console.log('slice', programmingLanguage1.substring(1, 5)); // avaS
---------------------------------------------------------
// replace, replaceAll - Замена (одного и всех)символов символов в строке.
const programmingLanguage2 = 'JavaScript';
console.log('replace', programmingLanguage2.replace('a', 'A')); 
console.log('replaceAll', programmingLanguage2.replaceAll('a', 'A')); 

Для замены несколько раз:
console.log(myInfoText.replaceAll('JavaScript', 'javascript').replaceAll('JS', 'js'));
---------------------------------------------------------
// trim() - удаление лишних пробелов
const nameOfUser = prompt('Ты кто?')
console.log('nameOfUser', nameOfUser.trim());
---------------------------------------------------------
console.log(- 5); // Унарный минус
console.log(10 - 5); // Бинарный минус

// Инкремент и Декремент
let cupsOfCoffeee = 2;

cupsOfCoffee = + 5;
cupsOfCoffee += 1;
cupsOfCoffee = * 6; 
cupsOfCoffee = / 2; 
cupsOfCoffee *= 6;
cupsOfCoffee /= 2;
   
// Постфикc и префикс
let cupsCoffee = 0;

console.log('cupsCoffee++:', cupsCoffee++); // Возвращает исходное значение
   
console.log('++cupsCoffee:', ++cupsCoffee);
---------------------------------------------------------
//// Математические операторы
   +, -, *, /, %, **

// Взятие остатка от деления %
a % b – это остаток от целочисленного деления a на b

   alert( 5 % 2 ); // 1, остаток от деления 5 на 2
   alert( 8 % 3 ); // 2, остаток от деления 8 на 3

// Возведение в степень **
В выражении a ** b оператор возведения в степень умножает a на само себя b раз.

alert( 2 ** 3 ); // 8  (2 * 2 * 2, 3 раза)
alert( 4 ** (1/2) ); // 2 (степень 1/2 эквивалентна взятию квадратного корня)
alert( 8 ** (1/3) ); // 2 (степень 1/3 эквивалентна взятию кубического корня)
---------------------------------------------------------
//// Сравнение строк

// Операторы сравнения: 
> < >= <= == ===
Примечание: никогда в разработке веб-приложений не используй нестрогое сравнение ==. Оно является инициатором большого количества багов, так как производит преобразование типов. Используй исключительно строгое сравнение ===. Оно не преобразует типы и уменьшает шанс возникновения ошибок. 

console.log("'Ass' == 'ass'",'Ass' == 'ass'); // false
console.log('"A".charCodeAt()', 'A'.charCodeAt()); // 65
console.log('"a".charCodeAt()', 'a'.charCodeAt()); // 97

// String.fromCharCode() - Получится символ в обратную сторону из числа
console.log(String.fromCharCode(97)) // 'a'
console.log(String.fromCharCode(65)) // 'A

// == vs ===
// == сравнивает значения
console.log("'1' == 1", '1' == 1);
console.log("'200' > '21'", '200' > '21');
console.log("true == 1", true == 1);

// === сравнивает типы (рекомендовано)
console.log("1 === 1", 1 === 1)
console.log("true === 1", true === 1)
---------------------------------------------------------
//// Math() 
console.log('Math объекты');
console.log('Число Pi', Math.PI); // 3.141592653589793

//// Округление

// Math.round() – простое округление
console.log('Простое округление:');
console.log('Math.round(40.4)', Math.round(40.4)); // 40
console.log('Math.round(40.5)', Math.round(40.5)); // 41
console.log('Math.round(40.6)', Math.round(40.6)); // 41

// Math.floor() – округление вниз
console.log('Округление вниз:');
console.log('Math.floor(40.5)', Math.floor(40.5)); // 40
console.log('Math.floor(40.9)', Math.floor(40.99)); // 40

// Math.ceil() – округление вверх
console.log('Округление вверх:');
console.log('Math.ceil(40.1)', Math.ceil(40.1)); // 41
-------------------
//// Math.random(). Создание рандомного числа с помощью 

   function getRandomInt (min, max) {
      return Math.floor(Math.random() * (max - min + 1) + min)
   };
   console.log('getRandomInt', getRandomInt (3, 6));
---------------------------------------------------------
// .toFixed(x) - обрезает/сокращает значение
let result = Number((amount / rate).toFixed(2)); // .toFixed(2) - обрезает значение до 2х символов. 
---------------------------------------------------------
//// Условное ветвление

if (если да, то)
else (что-то другое)
if else (если другое "да", то)
switch case (случай) - замена else & if
? : - замена else if

//// {if} {else}

if (условие) {
  // Выполнится, если условие будет истинным
} else {
  // Выполнится, если условие будет ложным
}

let isFrontendDeveloper = true;

if (isFrontendDeveloper) {
   console.log('isFrontendDeveloper = true','You are a Front-End developer. Welcome to the team!');
} else {
   console.log('isFrontendDeveloper = false', 'You are not a Front-End developer');
}

const condition = 5 > 10; // вернет false
if (condition) {
  console.log('Выражение истинно!');
} else {
  console.log('Выражение ложно!');
}
Вывод: Выражение ложно!

let developerJobType = 'Front-End';

if (developerJobType === 'Front-End') {
   console.log('2000$');
} else if (developerJobType === 'Back-End') {
   console.log('1500$');
} else if (developerJobType === 'Full-Stack') {
   console.log('3500$');
} else {
   console.log('Зарплата не определена');
---------------------------------------------------------
//// switch case / break / default 

    let arg = prompt("Введите число?");
    switch (arg) {
    case '0':
    case '1':
        alert( 'Один или ноль' );
        break;

    case '2':
        alert( 'Два' );
        break;

    case 3:
        alert( 'Никогда не выполнится!' );
        break;
    default:
        alert( 'Неизвестное значение' );
    }
-------------------
   let developerJobType = 'Front-End';

   switch (developerJobType) {
      case 'Front-End':
         console.log('2000$');
         break;
      case 'Back-End':
         console.log('1500$');
         break;
      case 'Full-Stack':
         console.log('3500$');
         break;
      default:
         console.log('Зарплата не определена');
---------------------------------------------------------
//// ? : - замена else if

let favoriteDrink = '???'

let message = favoriteDrink === 'Coffeee' // условие 
   ? 'Your favorite drink is Coffeee' 
   // после '?' выполняет если условие 'true'
   : 'You most likely have a healthy CNS'; 
   // после ':' выполняет если условие 'false'

let question2 = prompt ('Сколько будет 2 * 2?') 
    question2 = Number(question2)

   question2 === 2 * 2
   ? alert('Ответ Верный') + correctAnswers++
   : alert('Ответ Неверный') + incorrectAnswers++;
-------------------
// Несколько операторов ? :

   let age = prompt('Возраст?', 18);

   let message = (age < 3) ? 'Здравствуй, малыш!' :
   (age < 18) ? 'Привет!' :
   (age < 100) ? 'Здравствуйте!' :
   'Какой необычный возраст!';

   console.log('message:', message);
-------
    inputValue === ""  
    ? console.log('Название задачи не должно быть пустым')

    : tasks[i-1].text === inputValue 
    ? console.log('Задача с таким названием уже существует')

    : callTaskTemplate(el.id, el.text) 
---------------------------------------------------------
// && (И) - Возвращает true если все аргументы истинны, а иначе – false:
   alert( true && true );   // true
   alert( false && true );  // false
   alert( true && false );  // false
   alert( false && false ); // false
// || (ИЛИ) - Если какой-либо из аргументов true, он вернёт true, в противоположной ситуации возвращается false.
   alert( true || true );   // true
   alert( false || true );  // true
   alert( true || false );  // true
   alert( false || false ); // false
// ! (НЕ)
// ?? (Оператор объединения с null) - Пропускает только значения "null" и "undefined" 

//// && (И) - Ищет и выводит значение с "false". Значения  "true" пропускаются.
Пропускает алгоритм далее если оба значения true:
if (existingUserLogin === userLogin && existingUserPassword === userPassword) {
  alert(`Добро пожаловать, ${userLogin}!`);
} else {
  alert("Логин и (или) Пароль введены неверно!");
}

console.log('//&& (И)//');

let userAge = 20;

if (userAge > 6 && userAge <= 18) {
   console.log('Пользователь ходит в школу');
} else {
   console.log('Пользователь НЕ ходит в школу');
}


let programingLanguage = 'JavaScript'
let experienceInYear = 1;

if (programingLanguage === 'JavaScript' && experienceInYear >= 1) {
   console.log('Добро пожаловать в нашу команду');
} else {
   console.log('Нужно бооольше опыта');
}

//// || (ИЛИ) - Ищет и выводит значение с "true". Значения  "false" пропускаются.

let currentHour = 10;

if (currentHour < 8 || currentHour > 20) {
   console.log('Наш офис Закрыт');
} else {
   console.log('Наш офис Открыт');
}


let userNickname = null;
let defaultNicname = 'User';

let nickname = userNickname || defaultNicname || 'noname';
console.log('nickname', nickname);

//// ! (НЕ)
let = answer = prompt ('How old are you?')
answer = Number(answer);

if (!answer) {
   alert('Enter your total number of years')
} else {
   alert(`You are ${answer} years old`)
}

Предположим, у нас есть сайт и мы хотим сделать какие-то действия, если пользователь не авторизован. Также у нас есть переменная isAuth:
let isAuth = false; //if (existingUserPassword === userPassword) {
   alert (`Добро пожаловать, ${userPassword}`)
} Пользователь не авторизован

if (!isAuth) {
  // Пользователь не авторизован, условие выполнится
}
Условие сработает, так как !isAuth === true и в if будет передано true. 

//// ?? (Оператор объединения с null)

// ?? - undefined, null 
console.log(false ?? 'Hello worldblat!');

// || - false, 0, "", NaN, undefined, null
console.log(false || 'Hello worldblat!');

---------------------------------------------------------
//// Циклы 
---------------------------------------------------------
// Переменные в циклах не видны за их пределами. 
// Чтобы переменные были видны ни только в цикле о и за ним, необходимо создать эту переменную заранее.
---------
/// .repeat(i) - вместо for, для loop повторений 

    function accumulate(ltr) {
    ltr = ltr.split('')
    return ltr.map((el, i) => el.toUpperCase() + el.toLowerCase().repeat(i)).join('-');
    }

    console.log(accumulate("abcd"));
-------------------
//// for () {}
-------------------
// for (начальное значение; условие (до тех пор пока); шаг) {
   ... тело цикла ...
};

   for(let i = 0; i<5; i++){
      
      console.log(i);
   }
   console.log("Конец работы"); 
   // 0
   // 1
   // 2
   // 3
   // 4
   // Конец работы
---------------------------------------------------------
//// Перебор Массивов
---------------------------------------------------------
/// for
-------------------
   for (let i = 0; i < developerNames.length; i++) {
      console.log('i', i);
      console.log('item', developerNames[i]);
   }
-------------------
// Посчитать сумму значений массива
-------------------
   let sum = null;
   for (let i = 0; i < arr.length; i++) {
      sum += arr[i];
   }
---------
    arr.forEach(el => {
        console.log(sum += el);
    });
-------------------
/// for of
-------------------
   for (const item of object) {
      // item - переменная отвечающая за элемент массива
      // object - название перебираемого массива/объекта
   };
-------
   for (const name of developerNames) {
      console.log('name', name);
   };
-------
   let iterable = [10, 20, 30];

   for (let value of iterable) {
      value += 1;
      console.log(value);
   };
   // 11
   // 21
   // 31
-------------------
/// forEach
-------------------
! Разница между forEach() и for()
- forEach() не прерывает цикл даже если есть if() и return и проходится до конца, выводя все значения и лишь потом идет к if() и return
- for() же прерывает цикл при необходимости.
- for (const el of arr) {} - тоже работает как и for ()
---------
! Метод forEach не возвращает никакое значение, он используется только для перебора массива и выполнения какого-либо кода для каждого элемента массива!

Не сработает:
    const check = fnArguments.forEach((el, i) => 
        isNaN(el)
    )
    console.log(check);

forEach - не нуждается в [i] при переборе, он сам сдвигает очередь элементов без упоминания счетчика циклов (i)

   let updatedStudent = [
      ...students,
   ];

   updatedStudent.forEach((el, i) => {
      el.job = "веб-разработчик";
   });

-------------------
   array.forEach(() => {}); 
   forEach это метод массива => необходимо обращаться к массиву.

   array.forEach((элемент, индекс, массив) => {
   // тело функции
   })

1. Метод forEach() принимает в себя функцию-callback. Callback - это функция, которая передается в другую функцию.
2. В свою очередь, функция принимает в себя три параметра:
   - Элемент. Данный параметр принимает в себя, непосредственно, значение каждого элемента массива по порядку.
   - Индекс. Данный параметр является опциональным (необязательным) и принимает в себя индекс текущего элемента массива.
   - Массив. Данный параметр также является опциональным и каждый раз принимает в себя текущий массив.
3. Тело функции. В данном месте мы прописываем всю необходимую логику. Она будет выполняться для каждого элемента массива.   

   developerNames = [
      'Maxim',
      'Jora',
      'Kiristina',
      'Alberto',
      'Djovanni'
   ];

   developerNames.forEach((name, index, array) => {
      console.log('name', name);
      console.log('index', index);
      console.log('array', array);
   });
---------------------------------------------------------
// Проверка четных / нечетных чисел с помощью оператора получения остатка от деления %.
   for (let i = 0; i <= 10; i++) {
      if (i % 2 == 0) {
         console.log(i);
      }
   }   
--------------------------------------------------------- 
// Найти делители числа и их количество

   let n = 12, divisor = [];
      for (let i = 1; i <= n; i++) {
         if (n % i == 0) {
            divisor.push(i);
         }
      }
console.log(`Делители числа ${n}:  ${divisor}`);
console.log(`Кол-во делителей числа:  ${divisor.length}`);
-------------------
function getDivisors (number) {
   let counter = 0;
      for (let i = number; i > 0; i--) {
         if (number % i === 0) {
            counter++;
         }
      };
      return counter;
}; // Найти кол-во делителей
---------------------------------------------------------
// Сохранить результат каждой итерации цикла for

Создать массив, и пушить результат при каждой итерации в него:
   var array = [];
   for (i = 1; i <= 3; i++) {
      var x = 0;
      x += (i); 
      array.push(x);
   }
// Or
   var array = [];
   for (i = 1; i <= 3; i++) {
      array.push(i);
   }
// Or
   var x = 0;
   for (i = 1; i <= 3; i++) {
      x += i;
   }
   var array = [],
// Or
   x = 0;
   for (i=0; i<=3; i++){
   x += (i); 
   array.push(x);
   }
   console.log(x);
-------------------
   for (let x = 0; x <= 10; x += 1) {
      console.log('x = ', x);
   };

   for (let value = 10; value >= 0; value -= 1) {
      console.log('value = ', value);
   };
-------------------
   for (let i = 0; i < 3; i += 1) {
      let newStudent = prompt("Введите имя нового студента!"); 
      if (newStudent) {
      newStudent = newStudent.trim();
      alert(`Добро пожаловать, ${newStudent}!`);
      }
   } // Будет повторять вывод тела функции (Вопрос об имени, Приветствие + Имя)  3 итерации, до тех пор пока (i < 3)

   let sequence = [1, 1, 2, 3, 5, 8, 13];
   for (let i = 0; i < sequence.length; i++) {
   console.log(sequence[i]);
   } 
   // 1, 1, 2, 3, 5, 8, 13
   // Цикл выводит следующее значение в консоль по порядку, тк указано sequence[i]. sequence с индексом [i] на начальном этапе подразумевает что i = 0 (тк отсчет указан с 0), а даной цифре отсчета соответствует индекс массива [0], в данном случае индекс массива sequence[0] = 1. А тк i++, цикл движется дальше на +1 ход вперед к следующему индексу массива.

// function calculateFlights (distance, isBusinessClass, milesTarget) {
      // body //
   };
   
   let targets = [Saskatoon = 3000, Asuncion = 7000,Tokio = 15000];
   let flightsVariant1 = calculateFlights(3118, true, targets[i]);
   let flightsVariant2 = calculateFlights(3617, false, targets[i]);

   for (let i = 0; i < targets.length; i++) {
      flightsVariant1();
      flightsVariant2(); 

   // Так не сработает! "ReferenceError: i is not defined". 
   // flightsVariant1/2 - как не знал до этого так и не знает что за значение "i"."i" становится известно лишь после объявления цикла.

   let targets = [Saskatoon = 3000, Asuncion = 7000,Tokio = 15000];
   for (let i = 0; i < targets.length; i++) {
      let flightsVariant1 = calculateFlights(3118, true, targets[i]);
      let flightsVariant2 = calculateFlights(3617, false, targets[i]);

   // Так сработает!
---------------------------------------------------------
//// Замена for (без возможности использовать индекс i)

const userNames = ['petya', 'vasya', 'evgeny'];

// name на каждой итерации свой собственный (локальный), поэтому используется const
for (const name of userNames) {
  console.log(name);
}
   // => "petya"
   // => "vasya"
   // => "evgeny"

---------------------------------------------------------
//// while - сначала смотрит условие, потом делает
---------------------------------------------------------
Код из тела цикла выполняется, пока условие condition истинно.

   let i = 0;
   while (i < 10) {
      console.log('i = ', i);
      i += 1;
   }

---------
    let romanNumerals = [];

    const lookup = {
    M:  1000,
    CM: 900,
    D:  500,
    CD: 400,
    C:  100,
    XC: 90,
    L:  50,
    XL: 40,
    X:  10,
    IX: 9,
    V:  5,
    IV: 4,
    I:  1
    };

    function convertToRoman(num) {
    let roman = "";
    for (let el in lookup) {
        while (num >= lookup[el]) {
        roman += el;
        num -= lookup[el];
        }
    }
    return roman;
    }

    for (let i = 5; i <= 100; i++) {
    romanNumerals.push(convertToRoman(i));
    }
    console.log(romanNumerals);

---------------------------------------------------------
//// do while - сначала делает, потом смотрит условие

   let i = 0;
   do {
      i += 1
      console.log('i = ', i);
   } while (i <= 5) // Выдаст 6, начав с 1 (тк сначала делает, а потом проверяет. Важна последовательность)

   let i2 = 0;
   do {
      console.log('i2 = ', i2);
      i2 += 1
   } while (i2 <= 5) // Выдаст 5, начав с 0 

---------------------------------------------------------
//// break 

   let z = 0;
   while (z < 10) {
   console.log(z);
   if (z === 3) break;
   z++;
   }
Остановится на 3х. Выведет: 0 1 2 3

---------------------------------------------------------
//// continue 

   for (let f = 0; f <= 5; f++) {
      if (f === 2) continue;
      console.log(f);
   }
Пропустит 2. Выведет: 0 1 3 4

---------------------------------------------------------
//// Массивы
---------------------------------------------------------
let target = [
   {nameTown:'Saskatoon', km: 3000}, 
   {nameTown:'Asuncion', km: 7000}, 
   {nameTown:'Tokio', km: 15000}
   ];

   for (let i = 0; i < target.length; i++) {
      const el = target[i];
      console.log(`Town name: ${el.nameTown} km: ${el.km}`);
   }
//Or
   target.forEach(el => console.log(el.nameTown)); // Saskatoon Asuncion Tokio
   target.forEach(el => console.log(el.km)); // 3000 7000 15000
-------------------
// Обычный вызов
   const el = target[0];
   console.log(`Town name: ${el.nameTown} km: ${el.km}`)
-------------------
let fruits = ["Яблоко", "Апельсин", "Слива"];
   alert( fruits[0] ); // Яблоко
   alert( fruits[1] ); // Апельсин
   alert( fruits[2] ); // Слива
-------------------
let numbers = [0, 0, 0, 0, 1];
let sum = 0;

for (let i = 0; i < numbers.length; i += 1) {

   numbers[i] = numbers[i] + 2; 
   // При каждом проходе цикла прибавляет к "i" +1, что пошагово продвигает цикл по элементам [ ] массива "numbers".
   Будет получаться:
   numbers = [2, 0, 0, 0, 1]; - 1й проход цикла
   numbers = [2, 2, 0, 0, 1]; - 2й проход цикла
   numbers = [2, 2, 2, 0, 1]; - 3й проход цикла
   numbers = [2, 2, 2, 2, 1]; - 4й проход цикла
   numbers = [2, 2, 2, 2, 3]; - 5й проход цикла

   sum = sum + numbers[i];
   // Складывает к переменной "sum" актуальное значение массива (в зависимости на какой позиции сейчас находится цикл)
   sum = 0 + 2 = 2
   sum = 2 + 2 = 4
   sum = 4 + 2 = 6
   sum = 6 + 2 = 8
   sum = 8 + 2 = 11
}
console.log(sum); // 11
-------------------
// Math.sqrt(x) - Извлечь корень из числа 

    console.log(Math.sqrt(25)); // 5
---------
    var isSquare = function (n) {
    return n >= 0 && Math.sqrt(n) % 1 === 0;
    }
    console.log(
    isSquare(-1),
    isSquare(0),
    isSquare(1),
    isSquare(25),
    isSquare(26)
    );
---------
// Выявить min / max значение из массива:

   let arr = [22,4,7];
   console.log(Math.min(...arr));
-------------------
// Разные типы значений
   let arr = [ 'Яблоко', { name: 'Джон' }, true, function() { alert('привет'); } ];

   получить элемент с индексом 1 (объект) и затем показать его свойство
   alert( arr[1].name ); // Джон

   получить элемент с индексом 3 (функция) и выполнить её
   arr[3](); // привет

// let cities = [
   {Valencia: 3118}, 
   {Lisbon: 3617}, 
   {Saskatoon: 3000}, 
   {Asuncion: 7000}
   ];

(cities[0].Valencia); // 3118
(cities[0]); // { Valencia: 3118 }
---------------------------------------------------------
//// Массивы (edit/delete/add)
---------------------------------------------------------
// Мутация массива 
JavaScript предоставляет несколько способов для добавления, удаления и замены элементов в массиве. Но некоторые из них используют мутацию, то есть видоизменяют изначальный массив, а некоторые — нет, они просто создают новый массив.
-------------------
I. Добавление: С мутацией
-------------------
Мутирующими методами для добавления элементов в массив:
  * array.push()
  * array.ushift()

-------------------
III. Удаление: С мутацией
-------------------
Методы для удаления элементов с мутацией: 
  * array.pop()
  * array.shift()
  * array.splice()
-------------------
II. Добавление: Без мутации
-------------------
Есть два способа, чтобы добавить новые элементы в массив без мутации изначального массива:
  * array.concat().
  * (...)
-------------------
   1) array.concat().
const arr1 = ['a', 'b', 'c', 'd', 'e'];

const arr2 = arr1.concat('f'); // ['a', 'b', 'c', 'd', 'e', 'f']
console.log(arr1); // ['a', 'b', 'c', 'd', 'e']
-------------------
   2) (...)
   Второй способ для добавления элементов без мутации — это использование оператора расширения. Оператор расширения записывается в виде трех точек (...) предшествующих массиву.

const arr2 = [...arr1, 'f']; // ['a', 'b', 'c', 'd', 'e', 'f']
const arr3 = ['z', ...arr1]; // ['z', 'a', 'b', 'c', 'd', 'e']
-------------------
IV. Удаление: Без мутации
-------------------
  * array.filter()
  * array.slice()
Метод array.filter() создает новый массив из первоначального массива, но новый содержит только те элементы, которые соответствуют заданному критерию.

   const arr1 = ['a', 'b', 'c', 'd', 'e'];
   const arr2 = arr1.filter(a => a !== 'e'); // ['a', 'b', 'd', 'f']  
// Or
   const arr2 = arr1.filter(a => {  
   return a !== 'e';
   }); // ['a', 'b', 'd', 'f']

В этом примере, критерием для отсеивания является неравенство 'e', поэтому новый массив (arr2) почти такой же, как и оригинальный, но содержащий только те элементы, которые не равны 'e'.

Некоторые особенности стрелочных функций:
Для однострочных стрелочных функций ключевое слово return подразумевается по умолчанию, так что вам не нужно писать его.
Однако для многострочных стрелочных функций нужно явно указывать возвращаемое значение.
Другой способ удалить элементы из массива без мутации — это использование array.slice(). (Не путать с array.splice())

array.slice() принимает два аргумента.
   Первый аргумент указывает откуда должна начинаться копия.
   Второй аргумент задает последний индекс не включительно.

const arr1 = ['a', 'b', 'c', 'd', 'e'];

const arr2 = arr1.slice(1, 5) // ['b', 'c', 'd', 'e']
const arr3 = arr1.slice(2) // ['c', 'd', 'e']

На строке с кодом const arr2 = arr1.slice(1, 5), arr2 создается путем копирования arr1 начиная с индекса 1 и заканчивая предыдущим индексом для 5 (то есть 4).

На следующей строке const arr3 = arr1.slice(2) показан полезный трюк. Если второй параметр метода array.slice() не задан, то метод берет копию с начального индекса до конца массива.
---------------------------------------------------------
//// Добавление элементов
---------------------------------------------------------
   const salariesOfDev = [400, 500, 600, 2000, 3500];
   const newSeniorDevSalary = 5000;

/// .push() - добавляет в конец 
   salariesOfDev.push(newSeniorDevSalary); 
   console.log('salariesOfDev', salariesOfDev);

/// .unshift() - добавляет в начало 
   salariesOfDev.unshift(101, 202, 303) 
   console.log('salariesOfDev', salariesOfDev);
-------------------
//// Удаление элементов
-------------------
/// .shift() - удаляет первый элемент массива и возвращает его значение в переменную (если имеется)
   const firstRemovedElement = salariesOfDev.shift(); 
   console.log('firstRemovedElement', firstRemovedElement);

/// .pop() - удаляет последний элемент массива и возвращает его значение в переменную (если имеется)
   const lastRemovedElement = salariesOfDev.pop(); 
   console.log('lastRemovedElement', lastRemovedElement);
-------------------
// Изменение элементов
   salariesOfDev[4] = 6000;
-------------------
// Получение элементов
-------------------
   array[3]
// Or
   array.at(3)

   array[array.length - 1] - чтобы получить последний элемент массива
-------------------
/// arr.slice 
-------------------
   let arr = ["t", "e", "s", "t"];
   alert( arr.slice(1, 3) ); // e,s (копирует с 1 до 3)

Он возвращает новый массив, в который копирует элементы, начиная с индекса start и до end (не включая END).
Оба индекса start и end могут быть отрицательными. В таком случае отсчёт будет осуществляться с конца массива
-------------------
//// Получить последний элемент массива
-------------------
  * array[array.length - 1] // Выполняется дольше всех
  * array.slice(-1) // Возвращает typeof: String
  * array.pop() // Вырезает элемент из массива

--------------------------------------------------------
// array.forEach()

Метод используется для перебора массива.

   arr.forEach(function callback(item, index, array)){
      ... делать что-то с item
      }); 

Он для каждого элемента массива вызывает функцию callback.
Этой функции он передаёт три параметра callback(item, i, array):
    item – очередной элемент массива.
    i – его номер.
    array – массив, который перебирается.

Например, этот код выведет на экран каждый элемент массива:
   ["Bilbo", "Gandalf", "Nazgul"].forEach(alert);
 // Вызов alert для каждого элемента

А этот вдобавок расскажет и о своей позиции в массиве:
   ["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
   alert(`${item} имеет позицию ${index} в ${array}`);
   });

//  arr = [
      {name:'Saskatoon', value: 3000}, 
      {name:'Asuncion', value: 7000}, 
      {name:'Tokio', value: 15000}
   ];
   
   arr.forEach(el => console.log(el.name));
   arr.forEach(el => console.log(el.value));
---------------------------------------------------------
//// Работа с методами массивов: map(), filter(), find(), findIndex(), some(), every()
---------------------------------------------------------
/// map - модифицирует каждый элемент массива и возвращает данные в новый массив
   ! Не забывай писать return! или если функция в одну строчку, то после "=>" подразумевается return.
   ! return в конце тел методов - нужен
   ! Так же помни, что return в конце цикла тормозит итерации цикла на 1-ом круге! (необходимо выносить его за цикл)
   ! В цикле методы перезаписываются. Возвращай их результат с помощью return

// Более быстрая запись поиска элемента и применение метода:
document.querySelectorAll(".task-item").forEach((taskItem) => {
    taskItem.style.color = taskItemTextColor;
  });
-------
	let result = arr.map(function(item, index, array) {
	// возвращается новое значение вместо элемента
	});

Например, здесь мы преобразуем каждый элемент в его длину:

	let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
	alert(lengths); // 5,7,6

-------
   const  salariesOfDevelopers = [ 400, 500, 600, 2000, 350];
   const updatedSalaries = salariesOfDevelopers.map((salary,index, array) => {
      return salary ** 2
   });
   console.log('updatedSalaries', updatedSalaries);
-------------------
   let searchName = 'barry';
   let index = inputArr.map(el => el.name).indexOf(searchName);

-------------------
/// filter - фильтрует каждый элемент массива и возвращает ЭЛЕМЕНТЫ в новый массив. (добавляет в массив если условия == true)

   const filteredSalaries = salariesOfDevelopers.filter((salary,index, array) => {
      return salary > 600 // [ 2000 ]
      // return index % 2 == 0 // [ 400, 600, 350 ]
   });
   console.log('filteredSalaries', filteredSalaries);
-------
    return newArr = arr.filter(el => {
      return el > 0
    })
-------------------
/// find - находит первый найденный элемент, выводит в новый массив

   const searchedSalary = salariesOfDevelopers.find(salary => {
      return salary > 500
   });
   console.log('searchedSalary', searchedSalary);

-------
	let users = [
	{id: 1, name: "Вася"},
	{id: 2, name: "Петя"},
	{id: 3, name: "Маша"}
	];

	let user = users.find(item => item.id == 1);
	alert(user.name); // Вася

-------------------
/// findIndex - Найти нужный элемент объекта в массиве.
Возвращает первый найденный индекс элемента, выводит в новый массив

   const searchedIndex = salariesOfDevelopers.findIndex(salary => {
      return salary > 500
   });
   console.log('searchedIndex', searchedIndex);
   
-------
findIndex() Найти нужный элемент объекта в массиве. 

   let patients = [
   { id: 1, name: "Максим" },
   { id: 2, name: "Николай" },
   { id: 3, name: "Ангелина" },
   { id: 4, name: "Виталий" }
];

   const indexOfPatients = patients.findIndex((el, i) => {
      return el.id ==  3;
   })
   console.log('indexOfPatients', indexOfPatients);
-------------------
/// some(), every() - Возвращают true/false
-------------------
some == true если хотя бы 1 элемент массива удовлетворяет условию
every == true если все элементы массива удовлетворяет условию

    const isBiggerThan10 = (element) => element > 10;

    console.log([2, 5, 8, 1, 4].some(isBiggerThan10));
    // expected output: false

    console.log([12, 5, 8, 1, 4].some(isBiggerThan10));
    // expected output: true
---------
   const elementExists = salariesOfDevelopers.some(salary => {
      return salary > 1000
   });
   console.log('elementExists', elementExists);

   const allElementExists = salariesOfDevelopers.every(salary => {
      return salary > 1000
   });
   console.log('allElementExists', allElementExists);
-------------------
/// new Set(arr) - позволяет хранить уникальные значения
-------------------
new Set(arr) - создает новый Объект Set, который позволяет хранить уникальные значения любого типа (примитивы или объекты). Набор можно повторять, а значения можно добавлять, удалять и проверять на принадлежность.

    // Creating a new set
    let mySet = new Set();

    // Adding values to the set
    mySet.add(1);
    mySet.add("Hello");
    mySet.add({name: "John"});

    // Checking the size of the set
    console.log(mySet.size); // 3

    // Checking if a value is in the set
    console.log(mySet.has("Hello")); // true

    // Removing a value from the set
    mySet.delete("Hello");
    console.log(mySet.has("Hello")); // false

    // Looping through the set
    for (let value of mySet) {
    console.log(value);
    }   
        // Output:
        // 1
        // Object {name: "John"}

---------
// Удалить все дубликаты в массиве
    let arr = [1, 2, 3, 4, 4, 3, 2, 1];
    arr = [...new Set(arr)];

    console.log(arr); // [1, 2, 3, 4]

Объект Set используется для хранения уникальных значений любого типа. Используя оператор распространения (...) для преобразования набора в массив, мы можем быстро получить массив только с уникальными элементами.
-------------------
/// .reduce() Сложение чисел массива, которые возвращаются в новую переменную

	array.reduce((аккумулятор, элемент, индекс, массив) => {
		// тело функции
	}, начальное значение)

---------
// Методы .reduce()
---------
// Удалить все рядом стоящие дубликаты:

    var uniqueInOrder = function(iterable) {
    try {
        iterable = iterable.split('');
    } catch { }

    return iterable.reduce((sum, n) => {
            if (sum[sum.length - 1] !== n) {
            sum.push(n);
        }
            return sum;
        }, []);
    };
    // sum[sum.length-1] - last элемент массива sum
    // , [] - sum = []

// Or
    function uniqueInOrder(iterable) {
        var result = []
        var last

        for (var i = 0; i < iterable.length; i++) {
            if (iterable[i] !== last) {
                result.push(last = iterable[i])
            }
        // Or
            // if (iterable[i] !== result[result.length-1]) {
            //    result.push(iterable[i])
            // }
        }
        return result
    }
    console.log(uniqueInOrder('AAAABBBCCDAABBB')) 
    // ['A', 'B', 'C', 'D', 'A', 'B']

---------
// Удалить все дубликаты:
    function duplicateCount(text) {
        text = text.toLowerCase().split('');
        let arr = [];

        for (let i = 0; i < text.length; i++) {
            if (!arr.includes(text[i])) {
                arr.push(text[i]);
            }
        }
        return arr
    }
    console.log(duplicateCount("abbcdea"))
    
---------
// Может складывать и перебирать не только числа

    function solution(roman){
    var conversion = {M: 1000, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1};
    
    return [ 'X', 'X', 'I' ].reduce((sum, roman) => sum + conversion[roman], 0);
    }
    console.log(solution('XXI')) //  21

---------

Метод reduce() принимает в себя два параметра:

   1. Функцию-callback, которая, в свою очередь, принимает в себя четыре параметра:
      * Аккумулятор. Он равен “начальному значению” при первом вызове функции, либо первому элементу массива, если “начальное значение” не задано. При последующих вызовах он равен результату предыдущего вызова функции.
      * Элемент - текущий элемент массива.
      * Индекс - индекс текущего элемента массива. Необязательный параметр.
      * Массив - текущий массив. Также является необязательным параметром.
   2. Начальное значение - значение, которое будет задано аккумулятору перед первым вызовом функции. Является необязательным параметром. Если он не задан, тогда аккумулятору присвоится значение первого элемента массива.
   3. Тело функции. В нем мы прописываем всю необходимую логику.
-------------------
/// .reduce() при работе с аргументами функции, с использованием ...rest

   function sum(...other) {
   console.log(other.reduce((acc, value) => acc + value)); 
}
   sum(1, 2, 3);  // 6
   sum(2, 2); // 4
   sum(10, 15, 249, 653, 846); // 1773
-------
   const euros = [29.76, 41.85, 46.5, 55.8, 43.6];

   const sum = euros.reduce((total, amount) =>  total + amount); 
   console.log('sum', sum); // 217.51 (Debugger to help)

* В этом примере reduce() принимает два параметра, total и число с которым сейчас идёт работа.
* Метод проходится по каждому числу в массиве, как бы это было с циклом for.
* Когда цикл только начинается, total имеет значение первого числа с начала массива (29.76), а числом в обработке становится следующее по этому же массиву число (41.85).
* Конкретно в этом примере, нам надо прибавить настоящее число к total.
* Такое вычисление повторяется для каждого числа в массиве и каждый раз настоящее число меняется на следующее число в массиве справа.
* Когда уже нет чисел в массиве, метод отдаёт значение total.
-------------------
/// sort() - Сортировка значений массива. Изменяет массив
Внимание! При передачи просто sort(), без callback, то будет преобразование элементов в 'string'

   salariesOfDevelopers = [ 400, 500, 600, 2000, 350];

   salariesOfDevelopers.sort((a, b) => {
      return a - b // Сортировка по возрастанию
      return b - a // Сортировка по убыванию
   });
   console.log('salariesOfDevelopers', salariesOfDevelopers);
-------
   let arr = [76, 25, 58, 91, 27]

   console.log('arr.sort', arr.sort());

Метод sort() работает по следующему принципу:

   * sort() должен вернуть значение меньше нуля, равное нулю или больше нуля.
   * Если вернется значение меньше нуля, сортировка поставит a по меньшему индексу, чем b, то есть, a будет идти первым.
   * Если вернется значение больше нуля, сортировка поставит b по меньшему индексу, чем a, то есть, b будет идти первым.
   * Если вернётся значение равное нулю, сортировка оставит a и b неизменными по отношению друг к другу.

   const array = ['b', 'd', 'c', 'a', 'e', 'f', 'g'];
   array.sort((a, b) => {
   if (a < b) {
      return 1;
   }
   if (a > b) {
      return -1;
   }
   return 0;
   });
   console.log(array); // ['g', 'f', 'e', 'd', 'c', 'b', 'a']
-------------------
/// .splice() - умеет добавлять, удалять и заменять элементы.
-------------------
Возвращает вырезанные элементы. Мутирует текущий массив. Может принимать новые значения для замены вырезанных.

Cинтаксис:
	arr.splice(startIndex[, deleteCount, elem1, ..., elemN])

Он начинает с позиции startIndex, удаляет deleteCount элементов и вставляет elem1, ..., elemN на их место. Возвращает массив из удалённых элементов.

	const cars = ['BMW', 'Mercedes', 'Lada'];
	const removedElements = cars.splice(0, 2, 'Audi', 'Bugatti')

	console.log('cars', cars); // 'Audi', 'Bugatti', 'Lada' 
	console.log('removedElements', removedElements); // 'BMW', 'Mercedes'
-------
Удалим 3 элемента и заменим их двумя другими:
	let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];

	// удалить 3 первых элемента и заменить их другими
	arr.splice(0, 3, "Давай", "танцевать");

	alert( arr ) // теперь ["Давай", "танцевать", "прямо", "сейчас"]
-------
Метод splice также может вставлять элементы без удаления, для этого достаточно установить deleteCount в 0:
	let arr = ["Я", "изучаю", "JavaScript"];

	// с позиции 2
	// удалить 0 элементов
	// вставить "сложный", "язык"
	arr.splice(2, 0, "сложный", "язык");

	alert( arr ); // "Я", "изучаю", "сложный", "язык", "JavaScript"
-------
Отрицательные индексы разрешены

В этом и в других методах массива допускается использование отрицательного индекса. Он позволяет начать отсчёт элементов с конца, как тут:
	let arr = [1, 2, 5];

	// начиная с индекса -1 (перед последним элементом)
	// удалить 0 элементов,
	// затем вставить числа 3 и 4
	arr.splice(-1, 0, 3, 4);

	alert( arr ); // 1,2,3,4,5
-------------------
// slice - возвращает вырезанные элементы. Не мутирует текущий массив. 
! Для обрезки до конца используй один параметр .slice(i)
Если писать .slice(i, iterable.length - 1) может быть ошибка

const agesOfDevelopers = [25, 18, 45, 30];

const slicedAgesOfDevelopers = agesOfDevelopers.slice(0, 2);
console.log('slicedAgesOfDevelopers', slicedAgesOfDevelopers);
console.log('agesOfDevelopers', agesOfDevelopers);
-------------------
// indexOf - возвращает индекс искомого элемента в переменную
(или используй для объектов "findIndex")
 
Синтаксис:
	arr.indexOf(searchElement, fromIndex = 0)

   const favoriteFood = ['Мясо', 'Торт', 'Кефирчик'];

   const indexOfFood = favoriteFood.indexOf('Мясо')
   console.log('Element:', favoriteFood[indexOfFood], 'Index:', indexOfFood);
---------
   const myText = 'Здесь должна была быть шутка, но я ее не придумал';

   console.log('indexOf', myText.indexOf('о')); // 7
   console.log('indexOf', myText.indexOf('шутка')); // 23
   console.log('indexOf', myText.indexOf('мыш кыш')); // -1

   console.log('includes', myText.includes('не придумал')); // true

-------------------
/// .match() - используется для поиска в строке совпадения с предоставленным выражением и возвращает совпадения в виде массива. Или возвращает null, если совпадений не найдено.
// для поиска совпадения можно использовать indexOf() или .includes()

^: Соответствует началу строки.
$: Соответствует концу строки.

Рекомендуется использовать символы ^ и $ при поиске точного соответствия шаблона и не использовать их, когда вы ищете конкретный шаблон в большей строке.

    let pattern = /(I|II|III|IV|V|VI|VII|VIII|IX|X)/;
    let string = "This is Roman numeral X";
    console.log(string.match(pattern));

Однако, если вы хотите убедиться, что вся строка совпадает, то рекомендуется включить символы ^ и $.
    let pattern = /^(I|II|III|IV|V|VI|VII|VIII|IX|X)$/;
    let romanNum = 'X';

!!! /^(X|(IX|IV|V?I{0,3}))$/ проверяет наличие пустой строки, которая начинается и заканчивается либо X, либо (IX|IV|V?I{0, 3}). Поэтому на '' видит совпадение. 
Исправить можно с помощью Boolean(str.trim():
    const str = ''
    if (Boolean(str.trim()) && /^(X|(IX|IV|V?I{0,3}))$/.test(str)) {
        console.log('str:',str); // не пропустит пустую строку
    }

/CM|CD|XC|XL|IX|IV|\w/g 
    - \w - ищет совпадения в любом символе слова
    - Флаг "g" в конце указывает глобальный поиск, что означает, что будут возвращены все совпадения во входной строке, а не только первый
---------
// Как понять регулярное выражение (пример с римскими цифрами)
    const rome = 
        /^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$/;

(M{0,4}) - означает что в строке могут находится от 0 до 4 М
(IX|IV|V?I{0,3}) - в строке могут находится IX,IV, от 0 до 3 I, а так же 0 или 1 V перед 0-3 I

Регулярное выражения для фильтрации чисел от 1 до 10:
/^([1-9]|10)$/; - () скобочки важны! Иначе будет пропускать 11 как 1 и тд

/^-?\d+\.?\d*$/
    ^: Соответствует началу строки.
    -?: Соответствует необязательному - символу, указывающему отрицательное число.
    \d+: соответствует одной или нескольким цифрам.
    \.?: Соответствует необязательному символу . с указанием десятичной запятой.
    \d*: совпадает с нулем или более цифрами после необязательной десятичной запятой.
    $: Соответствует концу строки.

    let numberRegex = /^-?\d+\.?\d*$/;
    let rangeRegex = /^[1-9]|10$/;

    console.log(
        numberRegex.test("-1234") & rangeRegex.test("-1234")); // false
    console.log(
        numberRegex.test("12.34") & rangeRegex.test("12.34")); // false
Следующие строки будут соответствовать шаблону:
    -1234
    -12.34
    1234
    12.34
    .34
Следующие строки не будут соответствовать шаблону:
    -
    12.3.4
    12a34
    12 34
---------
/^[\/\*\-\+]$/ - Фильтр по операторам / * - +
Их нужно писать через \ обратный слеш

-------------------
//// new RegExp - создание регулярного выражения
-------------------
	const elements = ["#", "!"];
	const regex = new RegExp(`[${elements.join('')}]`);

	console.log(regex); // /[#!]/
-------------------

Функция сравнения массивов:
    function getCount(str) {
        return (str.match(/[aeiou]/ig)||[]).length;
    }
    getCount("abracadabra")
    
Функция getCount использует метод match для поиска всех вхождений символов «a», «e», «i», «o» или «u» в строке независимо от регистра. Метод match возвращает массив совпадающих символов или null, если совпадений не найдено. Флаг /i делает процесс сопоставления нечувствительным к регистру, а флаг g заставляет его сопоставлять все вхождения, а не останавливаться на первом совпадении. ||[] используется в качестве запасного варианта для возврата пустого массива, если возвращается значение null, чтобы можно было использовать свойство .length. Свойство .length возвращает количество элементов в массиве, то есть количество гласных в строке. Функция возвращает это количество гласных в качестве окончательного вывода.
-------------------
// .includes() - элемент есть/нет (true/false)
Метод проверяет, содержит ли строка/массив заданный элемент
!!! Сам перебирает массив!

Синтаксис:
    перебираемый_массив.includes(искомый_элемент)

    const technologies = ['JS', 'HTML', 'CSS'];

    const isTechnologiesExists = technologies.includes('CSS')
    console.log('isTechnologiesExists', isTechnologiesExists);

-------------------
/// /^[\/\*\-\+]$/.test() - замена .includes() 
-------------------
Синтаксис:
    регулярное_выражение.test(валидируемый_элемент)

    function calculator(string) {
        const res = string.split(' ').filter((el) => /[-+*/]/.test(el))
        console.log(res);
    }
    calculator('1 + 1')
    
метод includes() принимает строку в качестве аргумента, но в этом случае вы передаете регулярное выражение.

Чтобы устранить эту проблему, можно использовать метод test() регулярного выражения вместо метода includes()). Метод test() возвращает логическое значение, указывающее, соответствует ли регулярное выражение строке.

-------------------
/// eval(string) - преобразовывает и считает строку уравнения в Number 
-------------------
    function calculator(string) {
        const res = eval(string);
        console.log(res);
    }
    calculator('1 + 1') // 2

-------
// Or Boolean()
-------
С помощью ! (НЕ) трансформируем в Boolean(), если нужно найти что-то с отрицанием (например добавить элемент если он отсутствует)
Или просто использовать Boolean() без отрицания 

    let technologies2 = {
        langs: ['JS', 'HTML', 'CSS'],
        libs: ['React', 'Vue']
    };
    let searchWord = 'name'

    if (!technologies2[searchWord]) {
        technologies2 = {
            ...{name: 'Maxim'},
            technologies2,
        }
    }
    console.log('searchWord:', technologies2);
-------
// Аналогия записи без spreed
-------
    if (!this.words[word]) {
        this.words[word] = {
            word, 
            description,
        };

-------
// object.hasOwnProperty(prop)
-------
    o = new Object();
    o.prop = 'существует';

    function changeO() {
    o.newProp = o.prop;
    delete o.prop;
    }
    o.hasOwnProperty('prop');   // вернёт true
    changeO();
    o.hasOwnProperty('prop');   // вернёт false
-------
    add (word, description) {
        if (!this.words.hasOwnProperty(word)) {
            this.words[word] = {
                word, 
                description,
            }
        }
    }
Можно проверять, есть ли такое свойство в объекте, через метод hasOwnProperty или, если необходимо, так же проверять и в прототипе через метод in.
-------
// [key] in arr (Для Объектов)
-------
    let user = {
        name: 'Maxim',
        age: 21,
    }
    console.log('name' in user ); // true

-------------------
// split - разделяет массив(и слова). Принимает в себя разделитель.

   const listOfOrders = 'Майка, шорты, кроссовки, рюкзак';

   const listOfOrdersArray = listOfOrders.split(', ')
   console.log('listOfOrdersArray', listOfOrdersArray);

---------
    function calculator(string) {
        const res = string.split(' ')

        console.log(res); // [ '1', '+', '1' ]
    }
    calculator('1 + 1')
---------
/// split(/[-_]/) - Разделить слова где есть определенные символы 
---------
// split(/\s+/) - удаляет все виды пробелов 

    function toCamelCase(str){
        let words = str.split(/[-_]/);
        let camelCased = words[0];
        for (let i = 1; i < words.length; i++) {
            camelCased += ((words[i][0].toUpperCase() + words[i].substring(1)))
        }
        return camelCased;
    }

    console.log(toCamelCase("the-stealth-warrior")); // "theStealthWarrior"
    console.log(toCamelCase("The_Stealth_Warrior")); // "TheStealthWarrior"

---------
    function getCount(str) {
        const vowels = ['a', 'e', 'i', 'o', 'u' ]

        return str.split('')
        // [
        'a', 'b', 'r', 'a',
        'c', 'a', 'd', 'a',
        'b', 'r', 'a'
       ]
    }
    console.log(getCount("abracadabra"));

-------------------
// join - превратить массив обратно в строчку. Принимает в себя разделитель.

   const ordersString = listOfOrdersArray.join('; ')
   console.log('ordersString', ordersString);
-------------------
// reverse - полностью переворачивает массив

let numbers = [1, 10, 5, 15]
numbers.reverse();
console.log('technologies', numbers);
---------------------------------------------------------
/// Объединение массивов 
---------------------------------------------------------
// concat() 
-------------------
	[1, 2, 3].concat([4, 5, 6]) // [1, 2, 3, 4, 5, 6]
---------
	let currentDevelopers = ['Maxim', 'Oleg'];
	let newDevelopers = ['Anton', 'Gleb']

	let allDevelopers = currentDevelopers.concat(newDevelopers);
	console.log('allDevelopers', allDevelopers);
---------
// Выравнять массив:

	let arr = [["#"], ["!"]];
	let newArr = [].concat(...arr);
	
	console.log(newArr); // Output: ["#", "!"]
-------------------
// Spreed-оператор "..." 
-------------------
    allDevelopers = [
    ...newDevelopers,
    ...currentDevelopers
    ];
    console.log('allDevelopers', allDevelopers);

-------------------
/// Когда делаем перебор Объекта через 
for in и добавляем его новый Объект: el нужно писать в [].
// [el]: arr[el]

/// Не забывай упоминать ..obj, при добавлении в его самого 
//  newObj = {
        ...newObj,
        [el]: arr[el]
    }

    for (const el in arr) {
            if (arr[el] !== undefined) {
                newObj = {
                    ...newObj
                    [el]: arr[el]
                }
            }
        }
-------------------
// Array.length - число элементов этого массива
-------------------
   let items = ['shoes', 'shirts', 'socks', 'sweaters'];
   console.log(items.length); // 4
---------------------------------------------------------
/// Найти индекс элемента в массиве объектов по элементу из другого массива
---------------------------------------------------------
   let orders = [4, 1, 2, 3]
   let patients = [
      { id: 1, name: "Максим" },
      { id: 2, name: "Николай" },
      { id: 3, name: "Ангелина" },
      { id: 4, name: "Виталий" }
   ];
-------------------
// for Метод

let patientsInOrder = [];

function giveTalonsInOrder (patients, orders) {
   for (let i = 0; i < orders.length; i++) {
      let queue = orders[i];
   
      for (let j = 0; j < patients.length; j++) {
         let patientId = patients[j]['id'];
   
         if (queue === patientId) {
            patientsInOrder.push(patients[j])
         }
      }
   }
   return patientsInOrder
}
let queueOfPatientsResult = giveTalonsInOrder(patients, orders);
console.log('giveTalonsInOrder', queueOfPatientsResult);

-------------------
// findIndex() Метод

function giveTalonsInOrder (patients, orders) {
   let rightQueue = [];

   for (let i = 0; i < patients.length; i++) {
      let searchElement = orders[i];
      let patientsIndex = patients.findIndex(el => el.id === searchElement)
      rightQueue.push(patients[patientsIndex]);
      }
      return rightQueue
}
queueResult = giveTalonsInOrder(patients, orders)
console.log('Patients in order:', queueResult);

-------------------
// map() Метод

function giveTalonsInOrder (patients, orders, ) {
   let patientsQueue = [], rightQueue = [];

   for (let i = 0; i < patients.length; i++) {
      let searchElement = orders[i];
      patientsQueue = patients.map(el => el.id).indexOf(searchElement); // INFO*
      rightQueue.push(patients[patientsQueue]);
   };
   return rightQueue
}
let queueResult = giveTalonsInOrder(patients, orders)
console.log('Patients in order:', queueResult);

// INFO* Ищем индексы элементов массива orders в другом массиве.
// Тк мы знаем что по очереди должен идти пациент № 4, затем № 1, № 2, № 3
// И знаем что индексы этих позиций очередности разбросаны в другом массиве на индексах [3, 0, 1, 2]
// Следовательно в такой последовательности и необходимо вызывать массив пациентов, для соблюдения правильной очереди 

---------------------------------------------------------
//// Объекты
---------------------------------------------------------
   const developer = {
      // key: value,
      'My name': 'Maxim',
      job: 'Front-End Dev',
      experience: 24,
      jobAllInfo: {
         type: 'Front-End',
         framework: 'ReactJS'
      }
   }

// Вывести значение объекта
console.log('name:', developer.'My name'); // ошибка 
console.log('jobAllInfo:', developer.jobAllInfo);
-------------------
// Вывести значение объекта (для некоторых случаев)
console.log('name:', developer['My name']);
-------------------
// Вывести значение Объекта из Массива
console.log(arr[i].key);
-------------------
// Передача переменных с ключом из объекта
const key = 'job'
console.log('job:', developer[key]);
-------
   let fruit = prompt('Корзина фруктов:', 'mango');
   let fruitBasket = {
      [fruit]: 6
   };
   console.log('fruitBasket', fruitBasket);
   const car = {
   name: "Toyota Corolla"
   };
-------
   const key = "color";
   car[key] = "red";

   console.log(car); // { name: 'Toyota Corolla', color: 'red' }
-------------------
// Цепочки обращения к объектам
console.log('type', developer.jobAllInfo.type);
console.log('type', developer['jobAllInfo']['type']);
---------------------------------------------------------
/// Объект - ссылочный тип данных
---------------------------------------------------------
// Примитивы (хранение данных) 
   У каждой переменной — своё отдельное значение

   let x = 10;
   let xCopy = x; // Копируется значение
   xCopy = 20;
   
   console.log(x); // 10 (значение оригинальной x не изменилось)
   console.log(xCopy); // 20
-------------------
// Не примитив - Объект (ссылочный тип)
   В переменных типах object хранится не сам объект, а ссылка на него.

   const object = { x: 10 };
   const objectCopy = object; // Копируется ссылка на объект
   objCopy.x = 20;

   console.log(object.x); // 20
   console.log(objCopy.x); // 20

То есть, по сути, в двух переменных хранится один и тот же объект, точнее ссылка на него.

   const entity = {};
   const entityCopy = entity;

   console.log(entity === entityCopy); // true (Тк entityCopy хранит ссылку на объект entity. А их ссылки будут равны)

   console.log({} === {}); // false (здесь разные ссылки)
   console.log([] === []); // false (здесь разные ссылки)

   console.log('hello' === 'hello'); // true (тк у примитивов нет ссылок)
---------------------------------------------------------
/// Передача примитива и объекта в функцию
---------------------------------------------------------
   const x = 10;
   const updateX = arg => arg = 20;
   updateX(x);

   console.log(x); // 10 (оригинал переменой не изменен)
-------------------
   const obj = { x: 10 };
   const updateObjX = arg => arg.x = 20;
   updateObjX(obj);

   console.log(obj.x); // 20 (обновилось исходное значение)
---------------------------------------------------------
/// Объекты add/delete/edit
---------------------------------------------------------
   const student = {
      id: 1,
      programmingLanguage: 'JavaScript',
      hasExperienceInReact: false,
   };

// Добавление значения в объект:
-------------------
   student.experience = 6;
   console.log('student', student);
-------
   const student = {
    	fullName: "Максим",
      experienceInMonths: 12,
      stack: ["HTML", "CSS", "JavaScript", "React"]
   };

   {
   	...student,
   	job: jobName
  }
-------------------
// delete - удаление из Объекта
   delete student.hasExperienceInReact;
   console.log('student', student);
   // Оставляет empty slot
-------------------
// Изменение
	student.experience = 12;
   console.log('student', student);

   const car = {
   name: "Toyota Corolla"
   };
-------------------
// Создание свойств
   car.engine = 1.6;
   car["maxSpeed"] = 185;
-------------------
// Обновление свойства
   car.name = "My Car";
   
   console.log(car); 
   { name: 'My Car', engine: 1.6, maxSpeed: 185 }
---------------------------------------------------------
/// Итерация объектов/ Перебор Объектов
---------------------------------------------------------
const goodInfo = {
    id: 1,
    price: 80,
    currency: '$',
    name: 'shoes',
}
-------------------
//// for in - проходится по ключам и свойствам объекта 
-------------------
// arr[i] in obj - Найти элементы массива в Объекте
    const arr = ['one', 'two', 'three'];
    const obj = {one: 1, two: 2, three: 3};

    console.log(arr[0] in obj) // true

---------
    for (const key in goodInfo) {
        console.log('key:', key);
        console.log('value:', goodInfo[key]);
    };
-------
    showAllWords () {
        for (const el in this.words) {
            console.log(el, '-', this.words[el].description);
        }
    } // В более сложных случаях когда объект имеет свои объекты с элементами

-------------------
// Object.keys() - Создает массив из ключей. Выводит значения в отдельный массив

const keys = Object.keys(goodInfo);
console.log('keys', keys);
-------------------
// Object.values() - Создает массив из значений. Выводит значения в отдельный массив

const values = Object.values(goodInfo);
console.log('values', values);
-------------------
// Object.entries() - Возвращает многомерный массив, элементами которого являются другие массивы из ключей и значений. Выводит все в отдельный массив

   const entries = Object.entries(goodInfo);
   console.log('entries', entries); 
    Выведет:
    // entries [
      [ 'id', 1 ],
      [ 'price', 80 ],
      [ 'currency', '$' ],
      [ 'name', 'shoes' ]
    ];
-------------------
   const car = {
      name: "Toyota Corolla",
      year: 2017,
      isNew: false
   };

   Object
      .entries(car) // Вернет массив [ ["name", "Toyota Corolla"], ... ]
      .forEach(arr => console.log(`${arr[0]}: ${arr[1]}`));

    Выведет:
   // name: Toyota Corolla
   // year: 2017
   // isNew: false

Метод Object.entries() возвращает многомерный массив, то есть массив, элементами которого являются другие массивы. В каждом из этих подмассивов arr в первом элементе arr[0] хранится название свойства, а во втором arr[1] — его значение.
-------------------
Однако есть более элегантный способ работы с массивами в параметрах. Рассмотрим тот же код, но с использованием деструктуризации:

Object
   .entries(car)
   .forEach(([key, value]) => console.log(`${key}: ${value}`));

Здесь мы "разобрали" массив на отдельные значения. Делается это с помощью квадратных скобок с указанием переменных, куда нужно поместить значения из массива. Таким образом, список аргументов стрелочной функции ([key, value]) означает, что первое значение из записи будет помещено в переменную key, а второе значение в переменную value.

---------------------------------------------------------
//// Деструктуризация - позволяет извлекать данные из массивов или объектов.
---------------------------------------------------------
function calcValues (a, b) {
   return [
      a + b,
      undefined,
      a * b,
      a / b,
   ];
};
   const result = calcValues(42, 10);

   const sum = result[0];
   const sub = result[1];
   console.log('result:', result);
   console.log('sum, sub:', sum, sub);
-------------------
// С помощью деструктуризации
   const result = calcValues(42, 10);

   const [sum, sub] = result;
   console.log('result:', result);
   console.log('sum, sub:', sum, sub);

// Or Запись короче: 
   [sum, sub] = calcValues(42, 10)
-------------------
// Игнорирование значений
-------------------
   const [sum, , mult, ...other] = calcValues(42, 10);
   console.log(sum, mult, other);
-------------------
// Значения по умолчанию
-------------------
   const [sum, sub = 'Вычитания нет', mult, ...other] = calcValues(42, 10);
   console.log(sum, mult, other, sub);
-------------------
   var a, b, rest;
   [a, b] = [1, 2];
   console.log(a); // 1
   console.log(b); // 2

   [a, b, ...rest] = [1, 2, 3, 4, 5];
   console.log(a); // 1
   console.log(b); // 2
   console.log(rest); // [3, 4, 5]

   ({a, b} = {a:1, b:2});
   console.log(a); // 1
   console.log(b); // 2

   ({a, b, ...rest} = {a:1, b:2, c:3, d:4});
   console.log(a); // 1
   console.log(b); // 2
   console.log(rest); // { c:3, d:4 }
-------
   var foo = ["1", "2", "3"];

   // без деструктурирования
   var one   = foo[0];
   var two   = foo[1];
   var three = foo[2];

   // с деструктурированием
   var [one, two, three] = foo;

-------------------
// Обмен значений переменных
-------------------
   var a = 1;
   var b = 3;

   [a, b] = [b, a];
-------------------
// Игнорирование некоторых значений
-------------------
	function f() {
		return [1, 2, 3];
	}

	var [a, , b] = f();
	console.log("A is " + a + " B is " + b);
   
После выполнения кода, a будет 1, b будет 3. Значение 2 игнорируется. Таким же образом вы можете игнорировать любые (или все) значения.
-------------------
// Деструктуризация с Объектами
-------------------
   const person = {
      name: 'Max',
      age: 20,
      address: {
         country: 'Russia',
         city: 'Moscow',
      },
   };

   const name = person.name;
   const age = person.age;
// Or
   const {
      name: firstName = 'Без имени', 
      age, 
      car = 'Машины нет',
      address: {country, city: homeTown}
   } = person;
   console.log(firstName, age, car, country, homeTown);
// key: variable - Смена значения переменной (если например занята)
   const {name, ...info} = person
   console.log(name, info);
-------------------
// Применение на практике 
-------------------
   function logPerson0 (per) {
      console.log(per.name, per.age);
   }
   logPerson0(person)
-------
   function logPerson1 ({name: firstName1, age}) {
      console.log(firstName1, age);
   }
   logPerson1(person)
---------------------------------------------------------
//// Symbol() - Создает уникальные ключи объекта. Позволяет использовать повторяющиеся ключи в объекте.
---------------------------------------------------------
// Пример ошибки однотипных ключей 
-------------------
let user = {
   name: 'Maxim',
   name: 'Igor',
   name: 'Michael',
}; // Сохраниться только последнее значение

console.log('user:', user); // { name: 'Michael' };

-------------------
// Решение с помощью Symbol() 
-------------------
const id = Symbol('name')

user = { 
   [id]: 'symbol value',
   name: 'Maxim',
   [Symbol('name')]: 'Igor',
   [Symbol('name')]: 'Michael',
};
console.log('user:', user);
console.log('user[id]:', user[id]);

-------------------
// in - Проверяет существует ли искомый ключ внутри объекта
-------------------
const searchInObject = 'name' in user
console.log('searchInObject', searchInObject); // true

console.log(id in user); // true
-------------------
В качестве имени ключа можно использовать переменные.
В объекте они означаются в "[]" 
   const key = "color";

   const car = {
   name: "Nissan Note",
   [key]: "silver"
   };

-------------------
// Создание скрытых свойств объекта с помощью Symbol()
-------------------
Использование символьных ключей гарантирует, что получить доступ к свойству мы можем, только имея ссылку на данный символ. Это может быть полезно, когда объекту нужно добавить свойство, которое другие части программы могут случайно изменить. При использовании symbol в ключе случайно зацепить свойство не получится. Также такие свойства не видны при переборе обычными способами (такими как цикл for...in или метод Object.entries()).

Для получения всех символьных ключей объекта можно использовать специальный метод Object.getOwnPropertySymbols().

   const car = {
   [Symbol("name")]: "Toyota Corolla",
   [Symbol("name")]: "Nissan Note"
   };

   const symbols = Object.getOwnPropertySymbols(car);
   for (const symbol of symbols) {
   console.log(`${symbol.description} - ${car[symbol]}`);
   }
   // Цикл выведет:
   // name - Toyota Corolla
   // name - Nissan Note

---------------------------------------------------------
//// Объединение нескольких Объектов в один
---------------------------------------------------------
   const developerInfo = {
      age: 25,
      experience: 3,
      name: 'Maxim'
   };

   const developerExtraInfo = {
      name: 'Igor',
      height: 180,
      isJunior: false,
   };

При слиянии, методы пропустят совпадающие ключи name и выведут только последний.
-------------------
// С помощью spreed оператора "..." (рекомендуется)
-------------------
   const developer = {
      ...developerInfo,
      ...developerExtraInfo,
      name: 'Nastya',
   };

   console.log('developer', developer); 
-------
Чтобы объединить объекты в массиве:
-------
При объединении объект-ы должны быть в "{}"

   const developer = [
      {...developerInfo},
      {...developerExtraInfo},
      {name: 'Nastya',}
   ];
-------------------
/// Object.assign() - копирование и объединение Объектов
-------------------
   Object.assign(Объект-хранилище, перемещаемый объект)
-------
   Object.assign(developerInfo, developerExtraInfo);

   console.log('developerInfo', developerInfo); 
    // developerInfo { a: 1, b: 2, c: 3 }
-------
   const developer2 = Object.assign({}, developerExtraInfo);

   console.log('developer2', developer2); 
     // developer2 { a: 1, b: 2, c: 3 }
-------------------
/// Копирование данных Объекта через for in
-------------------
!Главная суть: Каждый Объект должен копироваться отдельно. Каждый вложенный копируется отдельно. Если данные не копируются, значит ты где-то пропустил объект или не так скопировал или не весь! 

    let user = {
    name: "John",
    age: 30
    };

    let clone = {}; // новый пустой объект

    // давайте скопируем все свойства user в него
    for (let key in user) {
    clone[key] = user[key];
    }

    // теперь clone это полностью независимый объект с тем же содержимым
    clone.name = "Pete"; // изменим в нём данные

    alert( user.name ); // все ещё John в первоначальном объекте
-------
let pageDesign = [
    tasksItem = {
        create: {a: 'tasksItem', b: 'div'},
        paste: {a: '.tasks-list', b: 'appendChild'},
        valueAtr: {
            class:"task-item",
            dataName: 'taskId', dataValue: '1',
        }, ...
    ]
// Копирование каждого Объекта:
    archiveCopies.push([   
            {
                create: {
                    ...el.create
                },
                paste: {
                    ...el.paste
                },
                valueAtr: {
                    ...el.valueAtr
                }
            }
        ])
-------------------
/// Копирование Объекта с вложенными Объектами
-------------------
!Главная суть: Каждый Объект должен копироваться отдельно. Каждый вложенный копируется отдельно. Если данные не копируются, значит ты где-то пропустил объект или не так скопировал или не весь! 

Все вышестоящие способы не работают в исходном виде, они не копируют данные вложенных объектов, а копируют только ссылки!
Для копирования данных необходимо прописывать структуру вручную:

    let user2 = {
        man: {
            name: "John",
            age: 30,
            job: {
                status: 'middle',
            }
        }
    };

    let clone2 = {
        man: {
            ...user2.man,
            job : {
                ...user2.man.job,
            }
        }  
    }

        clone2.man.name = "Pete";
        clone2.man.age = 24;
        clone2.man.job.status = "sin";

        console.log('user2', user2 ); 
        console.log('clone2', clone2);
-------------------
let user2 = [
        man = {
            name: "John",
            age: 30,
            job: {
                status: 'middle',
            }
        }
    ];

    function indexEl(arr, el) {
        return arr.indexOf(el)
    }
    
    let clone2 = [
        man = {
            ...user2[indexEl(user2, man)],
            job : {
                ...user2[indexEl(user2, man)].job,
            }
        }    
    ]

        clone2[0].name = "Pete";
        clone2[0].age = 24;
        clone2[0].job.status = "sin"; 

        console.log('user2', user2 ); 
        console.log('clone2', clone2);

-------------------
/// Работа с Объектами. Вызов референса функции через Ключ Объекта
-------------------
! Используя ключ объекта, можно не только вывести значение ключа. 
  НО И вызвать функцию с помощью передачи ВЫЗОВА КЛЮЧУ!

    const usersData = [
        { id: 1, name: 'John' },
        { id: 2, name: 'Jane' },
        { id: 3, name: 'Bob' }
    ];

    function fetchAll() {
        return usersData;
    }

    const API = {
        users: {
            fetch: fetchAll
        }
    };

    console.log(API.users.fetch()); 
    // [
        { id: 1, name: 'John' },
        { id: 2, name: 'Jane' },
        { id: 3, name: 'Bob' }
    ]

---------------------------------------------------------
//// ?. Оператор опциональной последовательности 
---------------------------------------------------------
// ("?." вместо "&&" в if)

    const developer = {
    name: 'Maxim',
    job: 'Front-End Dev',
    experience: 24,
    jobAllInfo: {
        type: 'Front-End',
        framework: {
            nameFw: 'ReactJS'
        },
    }
    }
-------------------
// if (developer.jobAllInfo.framework.nameFw)
-------------------
   if (developer && developer.jobAllInfo && developer.jobAllInfo.framework && developer.jobAllInfo.framework.nameFw) {
      console.log('The developer already knows the framework');
   } else {
      console.log("The developer doesn't knows the framework");
   }
-------------------
// ?. Оператор опциональной последовательности 
-------------------
   if (developer?.jobAllInfo?.framework?.nameFw) {
      console.log('The developer already knows the framework');
   } else {
      console.log("The developer doesn't knows the framework");
   }
---------------------------------------------------------
//// Функции 
---------------------------------------------------------
     С помощью них предотвращают дублирование кода. 
     Функция вызывается добавлением () после нее

// Анонимная функция вызывается:
   (function (){
   console.log("work");
   })();
// Or
   (function (str){
   console.log(str);
   }("work"));
-------------------
В функцию мы можем передавать параметры (любые типы данных). Одним из параметров может быть другая функция (например callback, alert, console.log) 

// Function Declaration - объявление функции
   (Можем вызывать функцию до ее определения)
   
   function name(param) {}

   function sum0 (a = 1, b = 3) {
      console.log(a + b);
   }
   sum0(); // 4
// Or
   function sum1 (a, b) {
      console.log(a + b);
   }
   sum1(1, 3); // 4
// Or
   function sum2 (a, b = 3) {
      console.log(a + b);
   }
   sum2(1); // 4
---------------------------------------------------------
//// Callback — это функция, в основной функции, которая должна быть выполнена после того, как другая (вторая) функция завершила выполнение (отсюда и название: callback — функция обратного вызова).

При передачи коллбэка в функцию, скобки у передаваемой функции ставить не нужно.

Также функцию callback можно передать в виде анонимной функции – прописать прямо в круглых скобках вызываемой функции:

    // Принимаем коллбэк ourCallback()
    function firstFunc(ourCallback) {
    setTimeout(() => {
        console.log('Hello');
        ourCallback(); // Вызываем коллбэк в нужный момент
    }, 500);
    };

    firstFunc(() => {
    console.log('World');
    });

    // Вывод:
    // Hello
    // World

---------
   function f2(callback) {
   let i = 0;
   i+=1;
   callback(i);
   }

   function handler(val) {
   console.log(val+1);
   }

   f2(handler);
---------
   function sum03(a, b, callback) {
   const result = a + b;
   callback(result);
   }

   function displacer(res) {
      console.log('Результат:', res);
   }

   sum03(3, 10, displacer);

/* Что тут происходит?
Создаем функцию sum03 с параметрами 'a', 'b', 'callback' 
(параметрами могут быть любые данные, даже функции, как и callback в данном случае.)
'callback' - это лишь произвольное название функции (хотя тут больше похоже на переменную со значением, чем на функцию. Но так как callback принимает значение от функции - это функция), в которую мы далее будем передавать полноценную функцию со значениями displacer. 

Создаем переменную result которая выполняет сложение двух неизвестных переменных 'a' и 'b' (пока их значение undefined)

Назначаем что функция callback будет иметь и выводить параметр result который хранит результат сложения.

Далее создаем функцию с наименованием displacer.
(которая в дальнейшем будет назначена передавать свое значение в callback. По сути можно сказать что callback = displacer)

Функция displacer имеет параметр res.
Далее тело функции displacer будет выводить в консоли строку 'Результат:' и переменную res (которую перенимает значения из result)

Далее самое важное. Мы передаем (назначаем) наши параметры функции sum 
Теперь (a, b, callback) = (3, 10, displacer)
a = 3
b = 10
callback = функция displacer

Грубо говоря, общая картина такова, что сумма значений 
(a + b) = result
result = callback 
callback = displacer
А так как displacer передает значения в callback, а callback хранит в себе значение переменной result, то есть сумму (a + b), то для функции displacer нам необходимо сохранить это значение в переменную res.

3 + 10 = 13. Помещается в функцию (параметр) callback и храниться в переменной result в качестве параметра.
А наш параметр callback является функцией displacer которая так же хранит в себе аналогичную переменную res в качестве параметра.

Получается displacer это отражение callback, которая хранит в себе все ее значения с небольшими дополнениями. Которая могла бы вызываться по необходимости (в конце), то есть отдельно от выполнения главного тела функции sum, где участвует callback.
*/

// Или это же, но через анонимную функцию (без названия)

   function sum04(a, b, anon_function) {
      const result = a + b;
      anon_function(result);
   }

   sum04(5, 10, function(res01) {
      console.log('Результат:', res01);
   });

// callback с уже существующими функциями 

   function sum05(a, b, alert) {
      const result = a + b;
      alert('Результат: ' + result);
   }

   sum05(5, 11, alert)
   
---------------------------------------------------------
//// Return - позволяет вернуть результат(значение) из функции 
*return - останавливает выполнение функции

// let increaseByTwo = function (number) {
      let sum = 2 + number;
      return sum;
   };

   increaseByTwo(1); // Функция вернёт 3
   increaseByTwo(2); // Функция вернёт 4

Чтобы функция вернула значение, мы используем оператор return. После оператора указываем, что именно надо вернуть. В нашем случае значение переменной sum. Когда программа доходит до строки с return, функция отдаёт результат своей работы и выполнение кода из тела функции останавливается, иными словами происходит выход из функции.

Несколько вещей, которые нужно знать:

   -Код, написанный на новой строке после return, не выполняется.
   -Функция не может вернуть сразу много значений, она возвращает только один результат.
   -Если внутри функции нет return или после return не указано, какое значение нужно вернуть, функция вернёт undefined, иными словами, ничего.

---------------------------------------------------------
Обрати внимание на разницу между параметрами и аргументами. На практике зачастую эти слова взаимозаменяемы, но стоит понимать отличия:

    Параметр — это название переменной, которое указывается в объявлении функции. Они используются для многоразовости функции, для подставления в нее разных аргументов на место ярлыков(параметров). (price, count)
    Аргумент — это значение параметра, которое передается при вызове функции. (100, 5)

   function showTotalPrice(price, count) {
   console.log(price * count);
   };
   Данная функция имеет два параметра — цена (price) и количество (count). По сути это переменные, которым присваиваются значения при вызове функции.

   showTotalPrice(100, 5); // Выведет в консоль: 500
   showTotalPrice(350, 2); // Выведет в консоль: 700
   // Аргументы (100, 5)

---------------------------------------------------------
// document.querySelector('.селектор') - найти элемент
   console.log(document.querySelector('.селектор')) - удостовериться, что найден нужный элемент

// document.classList.remove() - удалить класс
   document.querySelector('.page').classList.remove('light-theme') - удалить класс в найденном селекторе

// document.classList.add() - добавить класс
   document.querySelector('.page').classList.add('dark-theme');  - добавить класс в найденном селекторе 

Но это некорректная запись. Для нормализации читабельности, скорости и удобства кода назначим переменной значение поиска, чтобы не искать ее каждый раз.

   let page = document.querySelector('.page');
   page.classList.remove('light-theme');
   page.classList.add('dark-theme');
-------------------
/// .onclick
-------------------
   let themeButton = document.querySelector('.theme-button');

   themeButton.onclick = function() {
   console.log('Кнопка нажата!');
   page.classList.remove('light-theme');
   page.classList.add('dark-theme');
   };

'onclick' свойство (по клику) - это событие для браузера 

Данная конструкция создает переменную которая будет хранить в себе найденный класс с кнопкой для смены темы сайта.
При нажатии на кнопку будет запущенна функция удаления светлой темы и добавления темной.

// .classList.toggle - чередование переключения классов.
Удаляет(remove) если есть, добавляет(add) если нет.

   селектор.classList.toggle('класс');
   page.classList.toggle('light-theme');

Итого код для переключения темы:
   let themeButton = document.querySelector('.theme-button');

   themeButton.onclick = function() {
   console.log('Кнопка нажата!');
   page.classList.toggle('light-theme');
   page.classList.toggle('dark-theme');
   };

---------------------------------------------------------
// .textContent - выводит текст класса или селектора, без HTML тегов

   let message = document.querySelector('.subscription-message');
   console.log(message.textContent);

С помощью .textContent можно переназначить текст
message.textContent = 'Измененный текст'
---------------------------------------------------------
'onsubmit' свойство - триггер на событие отправки формы (не кнопки!)

   let message = document.querySelector('.subscription-message');
   let form = document.querySelector('.subscription');

   form.onsubmit = function(evt) {
   // Инструкция ниже отменяет отправку данных
   evt.preventDefault();
   message.textContent = 'Форма отправлена!';
   };

---------------------------------------------------------
Отличия Function Declaration и Function Expression в том 
что FD мы можем вызывать до определения функции, а FE нет
---------------------------------------------------------
//// Рефакторинг 

Разработчики рефакторят свой код для того, чтобы он был понятен коллегам и самому автору через какое-то время, легко поддерживался, не содержал в себе повторов, огромных сложных конструкций и так далее. Здесь, как в школе: сначала пишем в черновик, пробуем, зачёркиваем, пробуем снова, пока не придём к решению, а потом аккуратно выводим в чистовик.

При этом рефакторингом занимаются все, даже самые крутые рок-звёзды из мира разработки.
---------------------------------------------------------
 Хороший код всегда состоит из множества частей, каждая из которых занимается только своей задачей.
---------------------------------------------------------
//// Arrow Function Expression
// Символ "=>" заменяет термин "function"

   let sum = (a, b) => {
      let calculate = a + b;
      return calculate;
   };
   let result = sum(3.14, 3.14);
   console.log('Result:', result);

// Создаем имя функции "sum", вводим в () параметры, с помощью => обозначаем что это стрелочная функция которая переходит к телу {}. После "=>" без указания "{}", дальнейший текст будет воспринят как для команды "return".

   const sayHello = () => {
      alert("Hello");
   };

   const sayHello = (name) => {
      alert(`Hello, ${name}`);
   };  

const sayHello = name => alert(`Hello, ${name}`);
const calc = (a, b) => a + b;

sayHello("Vasya"); // Выведет сообщение "Hello, Vasya"
console.log(calc(1, 2)) // Выведет в консоль: 3

   let sum = function (a, b) {
      return a + b
   } 

   let result = sum(3.14, 3.14);
   console.log('Result:', result);
//Or
   let sum = (a, b) => {
      let calculate = a + b;
      return calculate;
   }

   let result = sum(3.14, 3.14);
   console.log('Result:', result);
//Or
   let sum = (a, b) => a + b; 

   let result = sum(3.14, 3.14);
   console.log('Result:', result);
   // Только если функция состоит из 1 строчки

---------------------------------------------------------
//// Использование Arrow Function как callback

   function multiply (a, b, callback) {
      const result = a * b;
      callback(result);
   }

   multiply(5, 2, (multiplyResult) => {
      console.log('multiplyResult:', multiplyResult);
   });

---------------------------------------------------------
//// Замыкания - функция внутри функции

// Замыкания — это функции, ссылающиеся на независимые (свободные) переменные. Другими словами, функция, определённая в замыкании, «запоминает» окружение, в котором она была создана.
// Свободные переменные — это переменные, которые не объявлены локально и не передаются в качестве параметра.

   let numberGenerator = function() {
// Локальная переменная, которая доступна только в замыкании
      var num = 1;
      function checkNumber() {
         console.log(num);
      }
      num++;
      return checkNumber;
      }

   var number = numberGenerator();
   number(); // 2

В примере функция numberGenerator создаёт локальную «свободную» переменную num (число) и checkNumber (функция, которая выводит число в консоль). 
Функция checkNumber не содержит собственной локальной переменной, но благодаря замыканию она имеет доступ к переменным внутри внешней функции, numberGenerator. 
Поэтому объявленная в numberGenerator переменная num будет успешно выведена в консоль, даже после того, как numberGenerator вернёт результат выполнения.

Если посмотреть Debugger, то clg функции checkNumber будет выполняться последним. Почему? Тк идет передача этой функции в главную, с помощью return. А при вызове главной функции number(), следовательно и вызывается clg функции checkNumber.

-------------Разбор примера-------------
const createCounter = (initialValue = 0) => {
   return (valueToAdd) => {
      return initialValue + valueToAdd
   };
};

const addFive = createCounter(5);
const result = addFive(7);
console.log(result);

// Смотрим процесс через Debugger. До момента с назначением аргумента (5) функции createCounter все понятно. Далее это значение с параметром, упаковывается в переменную addFive. 
После, уже нынешняя переменная addFive(тобишь createCounter(5)) двигается далее и встречает return(1*), который возвращает в наш addFive вложенную анонимную функцию(со всеми ее значениями). 
То есть, теперь наш addFive != createCounter(5)
А имеет значение addFive = (valueToAdd) => {
      return initialValue + valueToAdd
   };
Это Debugger обработал первый(1*) return.
После процесс Debugger видит новый аргумент addFive(7)и переключается на него, одновременно упаковывая эти значения в переменную result.
И теперь самый важный момент. 
Параметр addFive стал (7). Но тут важно не ошибиться, addFive != исходному createCounter(5)
addFive имеет значение стрелочной функции с параметром (valueToAdd).
Поэтому при объявлении addFive(7), меняется параметр (valueToAdd). А дальше уже все понятно. Этот параметр используется в return для возврата initialValue + valueToAdd. 
Которые в итоге возвращаются в их анонимную стрелочную функцию которая = переменой addFive, которая уже ныне = переменой result, которая в последствии и выводится в консоль.

   createCounter = (initialValue = 0) => {
      let counter = initialValue;

      return (valueToAdd) => {
         counter += valueToAdd;
         return counter;
      };
   };

   const addTwo = createCounter(2);
   result = addTwo(10); // 12
   result = addTwo(5);
   result = addTwo(3);
   console.log(result);

---------------------------------------------------------
//// Область видимости переменных
---------------------------------------------------------
/// Глобальная область видимости
Позволяет переменной быть видимой из любой точки кода. Переменная считается глобальной, когда она объявлена вне функций и блоков:
const x = 10; // Глобальная переменная

   function show() {
   console.log(x); // Выведет 10
   }

/// Локальная область видимости (3 вида):
// Блочная -
Область видимости ограничена блоком кода (т.е. фигурными скобками { и }):

   if (true) {
   const x = 10;
   }
   console.log(x); // Ошибка ReferenceError: x is not defined
   / Переменная x будет доступна только внутри блока if

   // Исключение — var. Они не имеют блочной области видимости и доступны даже вне блока.

// Область видимости функции -
Ограничена функцией, в которой объявлена переменная (Аналогично блочному)

   function test() {
   const x = 10;
   }
   console.log(x); // Ошибка ReferenceError: x is not defined

// Модульная — область видимости ограничена модулем.

---------------------------------------------------------
/// Алгоритм поиска переменных
---------------------------------------------------------
   const x = 10;

   function show() {
   const y = 20;

   if (true) {
      const z = 30;
      console.log(x + y + z);
   }
   }
   show(); // Выведет в консоль 60   

В данном примере функция show() выводит в консоль сумму трёх переменных. При обращении к переменной x, движок JavaScript действует по такому алгоритму:

    Пытается найти переменную с именем x внутри блока if. Не найдя её, переходит к родительскому блоку наверх.
    Пытается найти переменную x в функции show(). Не найдя её, переходит к глобальному контексту.
    Находит глобальную переменную x и использует её значение.
    
   / Поиск происходит изнутри наружу. От локальных (точка отправления) к более глобальным

// При этом, если во внутреннем блоке уже найдена переменная с нужным именем, поиск останавливается:
   const x = 10;
   
   if (true) {
   const x = 20;
   console.log(x); // Выведет 20
   }
   console.log(x); // Выведет 10

---------------------------------------------------------
//// Выбор имени функции
---------------------------------------------------------
Функции, начинающиеся с…
    "get…" – возвращают значение,
    "calc…" – что-то вычисляют,
    "create…" – что-то создают,
    "check…" – что-то проверяют и возвращают логическое значение, и т.д.

showMessage(..)     // показывает сообщение
getAge(..)          // возвращает возраст (получая его каким-то образом)
calcSum(..)         // вычисляет сумму и возвращает результат
createForm(..)      // создаёт форму (и обычно возвращает её)
checkPermission(..) // проверяет доступ, возвращает логическое значение
---------------------------------------------------------
// Number.isInteger(value) определяет, является ли переданное значение целым числом.
---------------------------------------------------------
   function fits(x, y) {
   if (Number.isInteger(y / x)) {
      return 'Fits!';
   }
   return 'Does NOT fit!';
   }

   console.log(fits(5, 10));
   // expected output: "Fits!"

   console.log(fits(5, 11));
   // expected output: "Does NOT fit!"
---------------------------------------------------------
//// Дата и Время
---------------------------------------------------------
// Создаем Объект
   const date = new Date(); 
   console.log('date', date);

   const newDate = new Date(2000, 0, 31, 00, 00, 0, 0); 
/ newDate(year, month, date, hours, minutes, seconds, ms) 
/ Месяца: 0 (январь) до 11 (декабрь)

   console.log('newDate', newDate); 
/ Mon Jan 31 2000 00:00:00 GMT+0000 (Coordinated Universal Time)

-------------------
// Создание даты из строки
-------------------
Также new Date() может принимать в себя строку с датой:

   const date = new Date('December 17, 2006 03:24:00');
   console.log(date); // Thu Dec 17 2006 03:24:00 GMT...

Это будет работать, если в конструктор был передан единственный аргумент с типом данных string.
-------------------
// Date.parse() 
-------------------
   Анализирует строку на наличие даты и переводит её в миллисекунды
   console.log(Date.parse('December 17, 2006 03:24:00')); 
-------------------
// Конвертировать миллисекунды в объект Date()
-------------------
   const dateInMs = 1498555006770
   const date = new Date(dateInMs)

   console.log(date.toString())
   / Tue Jun 27 2017 12:16:46 GMT+0300 (RTZ 2 (зима))

---------
/// ().toString(2) - Преобразование числа в двоичное с помощью функции 

    console.log((1234).toString(2)); // 10011010010
-------------------
// variable.get_() Вывести значение даты
-------------------
console.log('year', newDate.getFullYear());
console.log('month', newDate.getMonth());
console.log('date', newDate.getDate());
console.log('seconds', newDate.getSeconds());

-------------------
// variable.getDay() Вывести день недели
-------------------
/ 0 (Вс) - 6 (Сб)
   console.log('day', newDate.getDay());
   if (newDate.getDay() === 1) {
      console.log('Сегодня Пн') 
   }

-------------------
// variable.set_() Установить/передать дату
-------------------
   newDate.setFullYear(1996, 0, 31) // Можно установить ПолнуюДату
   console.log('newDate.FullYear', newDate);

-------------------
// Расчет разности между датами
-------------------
// getTime()

   const date1 = new Date(2005, 4, 20);
   const date2 = new Date(2006, 4, 10);

   console.log('date1', date1.getTime()); 
   console.log('date2', date2.getTime()); 
   / кол-во мс с Jan 1, 1970 

   const difference = date2.getTime() - date1.getTime();
   console.log('difference', difference / 1000 / 60 / 60 / 24); 
   / разница в днях (1000 * 3600 * 24)
-------------------
// Высчитывание скорости выполнения кода
-------------------
   const startTime = Date.now()
   for (let i = 0; i < 1000000; i++) {
      // do something
   }
   const endTime = Date.now()
   console.log('endTime - startTime:', endTime - startTime, 'ms');

---------
    var start = performance.now();

    // Your code here

    var end = performance.now();
    var time = end - start;
-------------------
// timestamp - Date.now(). Количество мс с 1 января 1970 г.
-------------------
Чтобы добавить определенное число миллисекунд, можно использовать следующую запись:
    new Date(Date.now() + 5000)
В итоге мы получим дату, которая на 5000 миллисекунд больше текущей.
---------------------------------------------------------
//// Комбинаторное объединение с использованием Методов и Функций
---------------------------------------------------------
const getDateFormat0 = (date, separator = ".") => {

  const dateItem = date.getDate();
  const monthIndex = date.getMonth();
  const year = date.getFullYear();

  return [dateItem, monthIndex + 1, year]
    .map(addZero)
    .join(separator);
};

const addZero = (el) =>
  String(el).length === 1 ? `0${el}` : String(el);

console.log(getDateFormat(new Date()));
---------------------------------------------------------
//// Проверка класса: "instanceof"
---------------------------------------------------------
Оператор instanceof позволяет проверить, принадлежит ли объект указанному классу, с учётом наследования.

  if (!(date instanceof Date)) {
    return "Первый параметр должен быть экземпляром класса Date!";
  }
---------------------------------------------------------
// this - ключевое слово указывающее на текущий контекст выполнения кода (чаще всего this - Объект)
Применятся в Методах 
---------------------------------------------------------
Простыми словами, this — это объект, который "владеет" функцией, которая сейчас выполняется.
-------------------
// Пример работы this и Функции в Объекте
-------------------
    let student = {
        name: 'Lamar',
        stack: [
            'HTML',
        ],
        level: 1,
        improveLevel() {
            this.level += 1
            if (this.level === 2) {
                this.stack.push('CSS')
            } else if (this.level === 3) {
                this.stack.push('JavaScript')
            } else if (this.level === 4) {
                this.stack.push('React')
            } else if (this.level === 5) {
                this.stack.push('NodeJS')
                console.log('Студент выучил все технологии!');
            };
            return this
        },
    };

    let stud = student
    .improveLevel()
    .improveLevel()
    .improveLevel()
    .improveLevel()
    .improveLevel();
    console.log('stud', stud);

Примечание: цепочка из подряд идущих функций improveLevel() работает так, потому что improveLevel() возвращает объект student, а у объекта student есть метод improveLevel().
------------------
/// Глобальный this, globalThis
-------------------
При обращении из глобального контекста к this он будет указывать на глобальный объект. Для браузеров — это объект window
Для всех браузеров - window. Для NodeJS - global
    console.log('this', this);
К глобальному объекту можно также обратиться из любого контекста с помощью глобального свойства globalThis:
    console.log(globalThis);
-------------------
/// this в объекте
-------------------
Как сказано выше, this — это объект, который "владеет" кодом, который сейчас выполняется. Поэтому, при обращении к this из метода объекта, это ключевое слово будет указывать на этот объект:
-------
// Способы создания функций внутри объекта и обращение к ним
-------
* В функциях внутри объектов НЕ стоит ссылаться напрямую к имени объекта, это делает код не универсальным.
* Нужно использовать this.key, вместо user.key 
    const user = {
        name: 'Maxim',
        dateOfBirth: 2001,
        getName() {
        //  return user.name // (дубово, тк привязано к объекту user)
            return this.name // (можно исп. для других пользователей)
        },
        calculateAge() {
            const currentYear = new Date().getFullYear();
            return currentYear - this.dateOfBirth;
        },
        getAllInfo: function() {
            const age = this.calculateAge();
            console.log(`Имя: ${this.name}, Возраст: ${age}`);
        }
    }
    console.log('user.getName:', user.getName());
    console.log('calculateAge:',  user.calculateAge());
    user.getAllInfo();
-------------------
/// bind, call, apply - Методы для привязки к функции какого-то контекста (Применимо только к Функциям.)
-------------------
    const user2 = {
        name: 'Igor'
    }
    const newValueForThis = user.getName.call(user2) 
    console.log('newValueForThis', newValueForThis);

this из объекта user, будет заменен на user2, следовательно и name будет использовано из объекта user2
-------------------
// Различия bind, call, apply
-------------------
    const mainHero = {
        fullName: 'SpiderMan',
        health: 65,
        strength: 5,
    };
    const badHero = {
        fullName: 'SpiderMan',
        health: 55,
        strength: 10,
    }

    function printHeroInfo(extraInfo = '') {
        console.log(`Имя: ${this.fullName}, Здоровье: ${this.health}, Сила: ${this.strength}, ${extraInfo}`);
    }
-------
// Метод call()
-------
    printHeroInfo.call(badHero, 'Роль: Злодей'); 
С помощью call(variable) указываем this какой объект нас интересует
    Пример: this из объекта user, будет заменен на user2, следовательно и name будет использовано из объекта user2
-------
// Метод apply()
-------
    printHeroInfo.apply(badHero, ['Роль: Злодей']); 
Отличия: Метод call() принимает параметры в виде списка через запятую, а apply() — в виде массива:
func.apply(context, [arg1, arg2, ...])
-------
// Метод bind()
-------
    const bindedPrintHeroInfo = 
       printHeroInfo.bind(mainHero, 'Роль: Главный Герой') 
    bindedPrintHeroInfo(); 
Задает контекст this, но не вызывает функцию. При этом он возвращает новую функцию, с заданным this.
---------------------------------------------------------
//// Потеря контекста "this"
---------------------------------------------------------
    const user = {
        name: 'Maxim',
        programmingLang: 'JavaScript',
        getName() {
            return this.name;
        },
        getProgrammingLang() {
            return this.programmingLang;
        },
    }
    console.log('getName:', user.getName()); 
    // getName: Maxim
-------------------
/// Потеря контекста при сохранении объекта.функции в переменную
-------------------
    const newGetName = user.getName
    console.log('newGetName:', newGetName()); 
    // newGetName: undefined. 
Тк мы вызываем функцию newGetName() без контекста(без элемента перед точкой). Поэтому контекст ссылается не на user, а на глобальный объект windows.
-------
// Решение ситуации:
-------
    const newGetName = user.getName
    console.log('newGetName:', newGetName.call(user)); 
    // Через call указали контекст - объект user
-------
    // Если сделать так, то тоже сработает 
    (но потеряет возможность вызывать нужный объект):
    const newGetName = user.getName() // Вызываем f() тут
    console.log('newGetName:', newGetName); // () уже не надо 

Так же назначение, без ее использования, считается за вызов, это может сбить счетчик:

for (let i = 0; i < 5; i++) {
    let callFn = student0.improveLevel;
    let callForOther = callFn.call(student1); 
    // callFn.call(student1) не применятся далее, воспринимается как лишний вызов функции
    console.log(i, callFn.call(student1));
}
for (let i = 0; i < 5; i++) {
    let callFn = student0.improveLevel;
    let callForOther = callFn.call(student1);
    console.log(i, callForOther); 
    // Вызывается, результат вызовов верен
}
-------------------
/// Пример работы вызова Функции Объекта в другом Объекте
-------------------
    const user = {
        name: 'Maxim',
        programmingLang: 'JavaScript',
        getName() {
            return this.name;
        },
        getProgrammingLang() {
            return this.programmingLang;
        },
    }
    const user2 = {
        name: 'Maxim',
        programmingLang: 'JavaScript',
        getName() {
            return this.name;
        },
        // getProgrammingLang() {
        //     return this.programmingLang;
        // },
    }

    let callFn = user.getProgrammingLang // Чья f() Объекта
    console.log(callFn.call(user2)); // Выводим ее для user2
    // JavaScript

-------------------
/// Пример использования Функций Объектов
-------------------
const footballer = {
    fullName: 'Cristiano Ronaldo',
    attack() {
        console.log(`${this.fullName} сейчас с мячом и начинает атаку!`);
    },
    scoreGoal (sound) {
        console.log(`${this.fullName} забил гол! Вот это да!`);
        this.celebrate(sound);
    },
    celebrate (sound) {
        console.log(sound);
    },
    goToSubstitution: function (newPlayer) {
        console.log(`${this.fullName} уходит на замену. На поле выходит ${newPlayer}`);  
    }
};

    const attack = footballer.attack;
    const score = footballer.scoreGoal;
    const substitute = footballer.goToSubstitution;

    attack.bind(footballer)();
    score.call(footballer, "Сиииии");
    substitute.apply(footballer, ["Paulo Dibala"]);
-------------------
/// Потеря контекста при стрелочных функциях 
-------------------
    getProgrammingLang: () => {
        return this.programmingLang;
    } 
    // У стрелочной функции нет this
-------
Возможно только через "variable: function() {}" или "variable() {}"
    getProgrammingLang: function () {
        return this.programmingLang;
    }
    getProgrammingLang() {
        return this.programmingLang;
    }
---------------------------------------------------------
//// ООП - объектно-ориентированное программирование 
---------------------------------------------------------
/// function и class
-------------------
// Создаем объект с помощью function
-------
    function Animal (name) {
        this.name = name;

        this.getName = function() {
            return this.name;
        }
    }

    console.log('result', Animal('кот')); 
    // Пытаемся вызвать функцию для создания объекта: result undefined
    const cat = new Animal('кот');
    console.log('cat', cat);

----------------------------
// Создаем объект с помощью class (рекомендуется)
----------------------------
// Класс – это шаблон кода для создания объектов.
    * В классе устанавливаются:
    начальные значения (свойства) и поведение (методы).
// constructor() - это спец-я функция которая вызывается в первый же момент, и инициализирует начальные значения.
// Поля - это каждая сущность внутри constructor() 
   (this.name = name, name - поле)
// Методы - Функции в class (getName() - метод)

    class Animal {
        constructor(name) {
            this.name = name;
        }

        getName() {
            return this.name;
        }
    }

    const dog = new Animal('@');
    console.log('dog', dog);
    console.log('dog.name', dog.name);
    console.log('dog.getName', dog.getName());
-------------------
* Представим, что наземные млекопитающие – это класс. 
* У каждого из них есть четыре конечности, два глаза, каждому из них нужно питаться – это свойства с конкретными значениями, они общие для всех объектов. 
* Также животные могут быть домашними или дикими, травоядными или хищниками, ходить на четырех лапах или на двух – это свойства со значениями, которые задаются конкретному объекту. 
* А такие действия, как поспать, поесть, побежать – это методы.

-------------------
/// Создание класса с помощью функции-конструктора
-------------------
Один из способов создать класс - функция или, вернее, функция-конструктор. Это обычные функции, но с двумя соглашениями:
    Имя функции-конструктора должно быть с заглавной буквы.
    Функция-конструктор должна вызываться с помощью оператора new.
Создание и вызов функции-конструктора выглядит следующим образом:
-------
// Класс через функцию-конструктор
-------
    function Class(значениеСвойства) {
    this.названиеСвойства = значениеСвойства;
    this.названиеМетода = function() { /* ... */ };
    };

    const obj = new Class(переданноеЗначение);
-------
    function Pet(type, name) {
    this.type = type;
    this.name = name;
    this.favoriteAction = 'спать';
    this.say = function() {
        console.log(`${this.type} по имени ${this.name} любит ${this.favoriteAction}.`);
    };
    };

    const cat = new Pet('Кот', 'Барсик');

    console.log(cat);
    // Pet {type: 'Кот', name: 'Барсик', favoriteAction: 'спать', say: ƒ}

    cat.say();
    // Кот по имени Барсик любит спать.

-------------------
/// Создание класса с помощью ключевого слова class
-------------------
    class Class {};
    console.log('type of Class:', typeof Class); // type of Class: function
class – это всего лишь разновидность функции.

В случае с class действуют те же правила, что и с функцией-конструктором:
    Имя должно быть с заглавной буквы.
    Вызов происходит с помощью оператора new.
-------
// Создание класса
-------
    class Class {
    constructor(значениеСвойства) {
        this.названиеСвойства = значениеСвойства;
    }
    названиеМетода1() {} // не ставим ","!
    названиеМетода2() {}
    }

    const obj = new Class(переданноеЗначение);
-------
    class Pet {
    constructor(type, name) {
        this.type = type;
        this.name = name;
        this.favoriteAction = 'спать';
    }
    say() {
        console.log(`${this.type} по имени ${this.name} любит ${this.favoriteAction}.`);
    }
    };

    const cat = new Pet('Кот', 'Барсик');

    console.log(cat);
    // Pet {type: 'Кот', name: 'Барсик', favoriteAction: 'спать'}

    cat.say();
    // Кот по имени Барсик любит спать.
-------------------
// Особенности class
-------------------
class нельзя вызвать без оператора new. 
Если попытаться это сделать, то мы получим ошибку:
    class Class {};
    Class();
    // Uncaught TypeError: Class constructor Class cannot be invoked without 'new'
-------
Вывод класса в консоль начинается с 'class...', что открывает возможности для его отслеживания:
    class Class {};
    console.log(Class); // class Class {}
---------------------------------------------------------
//// Принципы ООП. 
Наследование, Инкапсуляция, Полиморфизм, Абстракция
---------------------------------------------------------
/// Наследование - создание дочерних классов на основе базовых
-------------------
class Plane {
    constructor(type, numOfPassengers) {
        this.type = type;
        this.numOfPassengers = numOfPassengers;
    }

    startFlight() {
        console.log('Полетели!');
    }
}
-------------------
/// extends - назначает дочерние элементы
-------------------
Делаем MilitaryPlane дочерним к обычному Plane(чтобы например пассажирский самолет не имел в себе доступных параметров которы доступны военному)

    class MilitaryPlane extends Plane {
        constructor(type) {
            super(type, 0); 
            // Вызов род-го конструктора и его параметров
        }

        setNumberOfGuns(NumberOfGuns) {
            this.NumberOfGuns = NumberOfGuns;
        }

        shoot() {
            console.log('Стреляем');
        }
    }
У дочерних есть доступ к родительским Методам и Полям. А у род-х к доч-м - нет.

    const plane = new Plane('Пассажирский', 100);
    console.log('plane', plane);
    plane.startFlight();

    const militaryPlane = new MilitaryPlane('Военный')
    militaryPlane.startFlight() // Вызывает первый найденный Метод. Если нет у себя (у дочернего), то вызывает у род-го
    militaryPlane.setNumberOfGuns('4');
    militaryPlane.shoot();
    console.log('militaryPlane', militaryPlane);
-------------------
/// instanceof - проверяет принадлежит ли объект определенному классу 
    console.log(militaryPlane instanceof Plane); // true
-------------------
/// Инкапсуляция - скрытие данных от доступа вне класса или при наследовании 
-------------------
    class SimpleClass {
    constructor() {
        this.value = 'Hello World!';
    }

    sayHi() {
        console.log(this.value);
    }
    };
-------
// Публичные данные:
-------
    const obj = new SimpleClass();

    // Читаем
    console.log(obj.value); // Hello World!
    obj.sayHi(); // Hello World!

    // Обновляем
    obj.value = 'Hello!';
    obj.sayHi(); // Hello!

-------
// Приватные данные:
-------
Приватные данные (Поля и Методы) мы можем вызвать только через помещение их в публичные методы и обращение через них. 
Публичный метод может вызывать цепочку из вложенных в друг друга приватных элементов.

Также перед тем как создать приватное свойство, в начале тела класса его нужно проинициализировать с помощью "#" перед конструктором

class SimpleClass {
    // Приватное свойство
    #privateValue

    constructor() {
        this.value = 'Hello World!';
        // Запись в приватное свойство
        this.#privateValue = 'JavaScript';
    }

    sayHi() {
        console.log(this.value);
        // Вызов приватного метода
        this.#privateMethod();
    }

    // Приватный метод
    #privateMethod() {
        // Чтение приватного свойства
        console.log(`I love ${this.#privateValue}`)
    }
    };

    const obj = new SimpleClass();

    console.log(obj.#privateValue);
    // Uncaught SyntaxError: Private field '#privateValue' must be declared in an enclosing class

    obj.#privateMethod();
    // Uncaught SyntaxError: Private field '#privateMethod' must be declared in an enclosing class

    obj.sayHi();
    // Hello World!
    // I love JavaScript

-------
class SimpleClass {
    #privateValue

    constructor() {
        this.#privateValue = 'JavaScript';
    }

    get value() {
        // сработает, при чтении obj.value
        return this.#privateValue;
    }

    set value(newValue) {
        // сработает, при записи obj.value = ...
        this.#privateValue = newValue;
    }
    };

    const obj = new SimpleClass();
    console.log(obj.value); // JavaScript

    obj.value = 'TypeScript';
    console.log(obj.value); // TypeScript
    
---------------------------------------------------------
/// get & set - вызов и изменение приватных элементов 
(за пределами класса)
---------------------------------------------------------
// Геттер get
-------------------
    console.log(developer.devSalary) 
    // Вызываем без ()!
-------------------
// Сеттер set
-------------------
    developer.setSalary = 5000 
    // Передаем новое значение в приватное поле

---------------------------------------------------------
/// Полиморфизм - одно действие, несколько реализаций 
-------------------
Полиморфизм означает «множество форм». 
Это способность вызвать один и тот же метод у разных объектов, и при этом они могут выполнять разные действия. То есть одинаковым будет только имя метода, его реализация будет зависеть от класса.

    class Animal {
        constructor(name) {
            this.name = name;
        }
        makeSound () {}
    }

    class Dog extends Animal {
        constructor(name) {
            super(name)
        }
        makeSound () {
            console.log('гаф');
        }
    }

    class Horse extends Animal {
        constructor(name) {
            super(name)
        }
        makeSound () {
            console.log('игого');
        }
    }
-------------------
/// Абстракция - использование только тех характеристик объекта которые с наибольшей точностью представляют его в определенной системе
-------------------
Говоря на примере, Абстракция это создание главного объекта с каркасом из обобщенных параметров, с целью его дальнейшего использования для уточнения в дочерних классах с помощью переопределения.

    class Footballer {
        constructor(name, club) {
            this.name = name;
            this.club = club;
        }

        shoot() {}
        celebrateGoal() {}
        pass() {}
    }

    class Forward extends Footballer {
        constructor(name, club) {
            super(name, club)
        }

        shoot() {
            console.log('Очень сильный удар');
        }

        celebrateGoal() {
            console.log('Даа! Я забил гол!');
        }

        pass() {
            console.log('Средний пас');
        }
    }

-------------------
/// static Статические поля и методы 
-------------------
Статические методы/свойства нужны тогда, когда наше свойство или метод не принадлежит конкретному объекту, а относится именно к классу.

Например, есть класс Person:
    class Person {
    constructor (name, age) {
        this.name = name;
        this.age = age;
    }
    }
    const person1 = new Person('Алекс', 25);
    const person2 = new Person('Игорь', 30);

Ключевое слово "static" применяется когда наше Поле или Метод не принадлежит конкретному объекту.
Либо когда внутри Метода не используется this.
Так же static можно использовать как приватный.

    class Car {
        static isCar(car) {
            return car instanceof Car
        } // проверяем соответствует ли переменная car классу Car
        
        static #initialParams = {
            name: 'Audi',
            maxSpeed: 150,
        } // Будет использовано если параметры не переданы

        constructor(name, maxSpeed) {
            this.name = name || Car.#initialParams.name;
            this.maxSpeed = maxSpeed || Car.#initialParams.maxSpeed;
        }

        drive () {
            console.log(`Машина ${this.name} сейчас в пути`);
        }
    }

    const car = new Car('BMW', 200);
    console.log('car:', car);

    const checkIsCar = Car.isCar(car) 
    // Обращаемся к статическому полю через название класса без new!
    console.log('checkIsCar:', checkIsCar);

    Car.#initialParams 
    // Private field '#initialParams' must be declared in an enclosing class

---------------------------------------------------------
//// DOM (Document Object Model) - дерево объектов веб-страницы
---------------------------------------------------------
DOM – это представление HTML-документа в виде дерева тегов.
Основой HTML-документа являются теги. 
Каждый HTML-тег - объект и является узлом. Текст, который находится внутри тега, также является объектом-узлом.

DOM-узлы – это обычные объекты JavaScript. Мы можем их изменять.
Например, создадим новое свойство для document.body:
    document.body.myData = {
        name: 'Caesar',
        title: 'Imperator'
    };
    alert(document.body.myData.title); // Imperator

Мы можем добавить и метод:
    document.body.sayTagName = function() {
        alert(this.tagName);
    };
    document.body.sayTagName(); // BODY (значением "this" в этом методе будет document.body)

Также можно изменять встроенные прототипы, такие как Element.prototype и добавлять новые методы ко всем элементам:
    Element.prototype.sayHi = function() {
        alert(`Hello, I'm ${this.tagName}`);
    };
    document.documentElement.sayHi(); // Hello, I'm HTML
    document.body.sayHi(); // Hello, I'm BODY

-------------------
/// Методы для поиска элементов:
-------------------
/// .getElementBy_() (устарел)
    const tasksBlock = document.getElementById('tasks');
    const allNavButtons = 
        document.getElementsByClassName('main-navigation');
    const allButtons = document.getElementsByTagName('button');

    console.log('tasksBlock:', tasksBlock);
    console.log('allNavButtons:', allNavButtons);
    console.log('allButtons:', allButtons);
-------------------
/// .querySelector() - выводит Первый элемент
-------------------
// поиск id через "#"
    const tasksBlock2 = document.querySelector('#tasks'); 
    console.log('tasksBlock2:', tasksBlock2);

// поиск классов через "."
    const classMainNav = document.querySelector('.main-navigation')
    console.log('classMainNav:', classMainNav);

// поиск тэга
    const firstButton = document.querySelector('button');
    console.log('firstButton:', firstButton);

// поиск атрибута через "[]"
    const thirdNavButton = document.querySelector('[data-button-id="3"]')
    console.log('thirdNavButton:', thirdNavButton);

// комбинированный поиск по селектору:
    const elements = document.querySelector("#main p.text");
    
В этом примере осуществляется поиск всех элементов <p> с классом .text, вложенных внутрь элемента с id = #main. Пробел указывает на поиск по потомкам.
-------------------
/// .querySelectorAll() - находит и выводит Все элементы
-------------------
    const allNavigationButtons = document.querySelectorAll('.main-navigation__button-item')
    console.log('allNavigationButtons:', allNavigationButtons);

Можем перебирать эти элементы:
    allNavigationButtons.forEach((el, i) => {
        console.log('i, el:', i, el);
    })
---------------------------------------------------------
//// Получить Переименовать Аттрибут
---------------------------------------------------------
// Получить имя класса:
    const taskWrapper = document.querySelector('.tasks__wrapper');
    console.log(taskWrapper.className);

// Назначить имя класса:
    taskWrapper.className = 'tasks__wrapper_1';
    console.log(taskWrapper.className);

// Получить имя тэга:
    const elemTagName = element.tagName

// Назначить id:
    const tasksBlock1 = document.querySelector('#tasks');
    tasksBlock1.id = 'new_tasks' 
    // Переименовали (верстка сломалась)

// Назначить href:
    const newNavButton = document.createElement('a');
    newNavButton.href = '#tasks_expired'

// Назначить data-*:
    newNavButton.dataset.buttonId = '4'

// Назначить text:
    newNavButton.textContent = 'Просроченные задачи'
    newNavButton.innerText = 'Просроченные задачи'

// Назначить аттрибут for:
    newNavButton.htmlFor = "task-1"
-------------------
/// .innerText 
    .textContent - вывести/изменить текстовое содержимое элемента. 
-------------------
    const submitButton = document.querySelector('.create-task-block__button');
    console.log(submitButton.innerText);
    console.log(submitButton.textContent);

// Переименовать значение элемента (не читает переданные теги):
    submitButton.textContent = '<b>Создать новую задачу</b>'
    // <b>Создать новую задачу</b>

// Изменить верстку (для вставки prettier кода используй ``)
    const submitButton = 
        document.querySelector('.create-task-block__button');
    submitButton.innerHTML = `<b>Создать новую задачу</b>`
    // Создать новую задачу //(bold)
-------------------
/// .innerHTML - содержит в себе код HTML-разметки элемента: 
-------------------
Свойство innerHTML позволяет получить HTML-содержимое элемента в виде строки. Мы также можем изменять его. 
Пример ниже показывает содержимое document.body, а затем полностью заменяет его:
    <body>
    <p>Параграф</p>
    <div>DIV</div>
    <script>
        alert( document.body.innerHTML ); // читаем текущее содержимое
        document.body.innerHTML = 'Новый BODY!'; // заменяем содержимое
    </script>
    </body>

Скрипты не выполнятся
Если innerHTML вставляет в документ тег <script> – он становится частью HTML, но не запускается.

Будьте внимательны: «innerHTML+=» осуществляет перезапись
Мы можем добавить HTML к элементу, используя elem.innerHTML+="ещё html".
Вот так:
    chatDiv.innerHTML += 
        "<div>Привет<img src='smile.gif'/> !</div>";
    chatDiv.innerHTML += "Как дела?";
На практике этим следует пользоваться с большой осторожностью, так как фактически происходит не добавление, а перезапись.

-------------------
/// .children - Вывести дочерние элементы класса
-------------------
    const createTaskForm = 
        document.querySelector('.create-task-block');
    console.log('createTaskForm.children', createTaskForm.children);
-------------------
// appendChild() - adding an element to a div
-------------------
To add an element to a div, you create an element and append it to the div using the appendChild() method:

    let div = document.createElement('div');
    div.id = 'content';
    div.className = 'note';

// create a new heading and add it to the div
    let h2 = document.createElement('h2');
    h2.textContent = 'Add h2 element to the div';
    div.appendChild(h2);

// add div to the document
    document.body.appendChild(div);

-------------------
/// data-атрибуты - это атрибуты, которые можно применять для удобного хранения в стандартных HTML-элементах различной полезной информации. (похоже на class id и тд)
-------------------
В нашем примере такие атрибуты (data-id) есть у элемента p:
    <p class="text" data-id="1">Первый абзац</p>
    const firstNavButton =
        document.querySelector('.main-navigation__button-item');

Стилизация элементов с использованием атрибутов data-*
В CSS можно выбирать HTML-элементы, основываясь на атрибутах и их значениях.

Выбрать элемент с таким именем атрибута, имеющим такое значение
    [data-size="large"] {
      padding: 2rem;
      font-size: 125%;
    }

Выбор можно ограничить элементом, классом, или чем-то другим
    button[data-type="download"] { }
    .card[data-pad="extra"] { }

Это может показаться интересным. Для стилизации в HTML/CSS используются, в основном, классы. И хотя классы — это замечательный инструмент (они отличаются средним уровнем специфичности, с ними можно работать с помощью удобных JavaScript-методов через свойство элементов classList), элемент может либо иметь, либо не иметь некоего класса (то есть, класс в элементе либо «включен», либо «выключен»). При использовании атрибутов data-* в распоряжении разработчика оказываются и возможности классов («включено/выключено»), и возможность выбора элементов, основываясь на значении атрибута, которое он имеет на том же уровне специфичности.

Выбор элементов, у которых имеется указанный атрибут
    [data-size] { }

Выбор элемента, атрибут которого имеет заданное значение
    [data-state="open"],
    [aria-expanded="true"] { }

Селектор "начинается с", использование которого приведёт к выбору элементов, атрибут которых содержит "3", а так же - что угодно другое, начинающееся с 3 - вроде "3.14"
    [data-version^="3"] { }

Селектор "содержит" указывает на то, что заданная строка должна содержаться где-то в значении свойства
    [data-company*="google"] { }

-------------------
/// dataset - получить коллекцию data-атрибутов
-------------------
    console.log(firstNavButton.dataset); 
    // DOMStringMap { buttonId → "1" }
На основе прошлого вывода:
    console.log(firstNavButton.dataset.buttonId); // 1

// Изменение data-атрибутов:
    firstNavButton.dataset.buttonId = '10';
    console.log(firstNavButton.dataset.buttonId); // 10
-------------------
/// .style - создание и изменение стилей
-------------------
В css: font-weight 
В js: fontWeight 
    firstNavButton.style.fontWeight = 'bold';
    firstNavButton.style.boxShadow = 'inset 0 0 0 3px #fff';

    firstNavButton.style = ''; // сброс всех стилей

К примеру, к CSS-свойству background-color мы обращаемся из кода через .style.backgroundColor = "green";

-------
// Функция переключения стилей с передачей аргументов через Объект
-------
	function toggleThemes({bodyBackground, taskTextColor, buttonBorder}) {
		document.body.style.background = bodyBackground 
		// Важно! При таком методе важно писать не ".style = background:", а ".style.background = "
		const taskItem = document.querySelectorAll('.task-item');
		taskItem.forEach(el => {
			el.style.color = taskTextColor
		});
		const findButtons = document.querySelectorAll('button');
		findButtons.forEach(el => {
			el.style.border = buttonBorder
		});
	}

	toggleThemes({
      bodyBackground: "#24292E",
      taskItemTextColor: "#ffffff",
      buttonBorder: "1px solid #ffffff"
   });
   toggleThemes({
      bodyBackground: "initial",
      taskItemTextColor: "initial",
      buttonBorder: "none"
   });

-------------------
/// style.cssText - задание нескольких стилей
-------------------
Для задания нескольких стилей в одной строке используется специальное свойство style.cssText:
    div.style.cssText=`color: red !important;
      background-color: yellow;
      width: 100px;
      text-align: center;
    `;
То же самое можно сделать установкой атрибута: div.setAttribute('style', 'color: red...')
Это свойство редко используется, потому что такое присваивание удаляет все существующие стили: оно не добавляет, а заменяет их.
-------------------
/// style.display - сброс стилей
-------------------
elem.style.display = "none" - Скрыть элемент
elem.style.display = "" - Вернуть элемент

если мы запустим этот код, <body> "мигнёт":
    document.body.style.display = "none"; // скрыть
    setTimeout(() => document.body.style.display = "", 1000); 
    // возврат к нормальному состоянию
---------------------------------------------------------
//// Создание HTML-элементов и добавление их в DOM
---------------------------------------------------------
/// .createElement() - создание нового элемента
-------------------
    const newNavButton = document.createElement('a');

    newNavButton.className = 'main-navigation__button-item'
    newNavButton.href = '#tasks_expired'
    newNavButton.dataset.buttonId = '4'
    newNavButton.textContent = 'Просроченные задачи'
    console.log(newNavButton);

Имя пользовательского элемента должно содержать дефис -, например, my-element и super-button – валидные имена, а myelement – нет.

Это чтобы гарантировать отсутствие конфликтов имён между встроенными и пользовательскими элементами HTML.
-------------------
/// node.remove() - удаляет элемент из DOM-дерева.
-------------------
    <div id="main">
    <p class="text" data-id="1">Первый абзац</p>
    <p class="text" data-id="2">Второй абзац</p>
    </div>
Удалим первый абзац:
    const p = document.querySelector("p");
    p.remove();

-------------------
/// Добавление созданных элементов в DOM 
-------------------
/// .prepend() - добавляет в начало
    .append() - добавляет в конец
    .before() - добавляет перед блоком
    .after() - добавляет после блока
    
    const mainNavigation = 
        document.querySelector('.main-navigation');
    mainNavigation.append(newNavButton)
-------------------
/// .after() - поменять местами теги (узлы)
-------------------
	<div id="first">Первый</div>
	<div id="second">Второй</div>
	<script>
	// нет необходимости вызывать метод remove
	second.after(first); // берёт #second и после него вставляет #first
	</script>

-------------------
/// .cloneNode() - клонирование узлов
-------------------
Как вставить ещё одно подобное сообщение?
   Мы могли бы создать функцию и поместить код туда. Альтернатива – клонировать существующий div и изменить текст внутри него (при необходимости).
Иногда, когда у нас есть большой элемент, это может быть быстрее и проще.
   Вызов elem.cloneNode(true) создаёт «глубокий» клон элемента – со всеми атрибутами и дочерними элементами. Если мы вызовем elem.cloneNode(false), тогда клон будет без дочерних элементов.
Пример копирования сообщения:
	<style>
	.alert {
	padding: 15px;
	border: 1px solid #d6e9c6;
	border-radius: 4px;
	color: #3c763d;
	background-color: #dff0d8;
	}
	</style>

	<div class="alert" id="div">
	<strong>Всем привет!</strong> Вы прочитали важное сообщение.
	</div>

	<script>
	let div2 = div.cloneNode(true); // клонировать сообщение
	div2.querySelector('strong').innerHTML = 'Всем пока!'; // изменить клонированный элемент

	div.after(div2); // показать клонированный элемент после существующего div
	</script>
-------------------
/// .classList - управление классами
-------------------
У classList есть несколько методов:
    _.classList.add() — добавляет класс к элементу
    _.classList.remove() — удаляет класс
    _.classList.toggle() — добавляет если нет / удаляет если есть
    _.classList.replace() — заменяет один класс другим

    const p = document.querySelector("p");
    p.classList.add("red");
-------------------
/// .replaceWith() - заменить один элемент на другой
-------------------
Заменим первый абзац на новый с помощью этого метода:
    const firstParagraph = document.querySelector("p");
    firstParagraph.replaceWith(newParagraph);
-------------------
/// closest - ищет ближайший родительский элемент 
    (например div или body)
-------------------
    elem.closest('селектор')   
Метод closest поднимается вверх от элемента и проверяет каждого из родителей. Если он соответствует селектору, поиск прекращается. Метод возвращает либо предка, либо null, если такой элемент не найден.

    const taskItemText = document.querySelector('.task-item__text'); 
    console.log(taskItemText); // элемент <span> 

    const taskItem = taskItemText.closest('.task-item')
    console.log(taskItem); элемент <span> принадлежит <div>

-------------------
/// matches - проверяет, удовлетворяет ли elem селектору, и возвращает true или false.
-------------------
Этот метод удобен, когда мы перебираем элементы (например, в массиве или в чём-то подобном) и пытаемся выбрать те из них, которые нас интересуют.
Например:
    <a href="http://example.com/file.zip">...</a>
    <a href="http://ya.ru">...</a>

    <script>
    // может быть любая коллекция вместо document.body.children
    for (let elem of document.body.children) {
        if (elem.matches('a[href$="zip"]')) {
        alert("Ссылка на архив: " + elem.href );
        }
    }
    </script>
    
-------------------
/// ._Attribute() - управление атрибутами
-------------------
    document.hasAttribute() - существует ли атрибут 
    document.getAttribute() - выводит значение атрибута
    document.removeAttribute() - удалить атрибут
    document.setAttribute('nameAttribute', 'value') - добавить атрибут (второй параметр обязателен, если null то '')

Имеет ли элемент указанный атрибут. Возвращает булево значение:
    const p = document.querySelector("p");
    console.log(p.hasAttribute("class")); // true

Устанавливает значение атрибута: 
    const p = document.querySelector("p");
    p.setAttribute("id", "firstParagraph")
    console.log(p.getAttribute("id")); // firstParagraph
-------------------
/// .insertAdjacentElement() - добавить элемент в нужную позицию в зависимости от указанных параметров.
-------------------
    elem.insertAdjacentElement(where, newElem);

Параметр where может принимать следующие значения:
    "beforebegin" – вставить newElem непосредственно перед elem,
    "afterbegin" – вставить newElem в начало elem,
    "beforeend" – вставить newElem в конец elem,
    "afterend" – вставить newElem непосредственно после elem.

newElem
    Элемент, добавляемый в DOM-дерево.

Наглядное отображение параметра position:
    <!-- beforebegin -->
    <p>
    <!-- afterbegin -->
    lorem-text
    <!-- beforeend -->
    </p>
    <!-- afterend -->

    mainNavigation.insertAdjacentElement('afterbegin', newNavButton)
Примечание: значения beforebegin и afterend работают только если targetElement находится в DOM-дереве и имеет родительский элемент.
-------------------
/// .insertAdjacentHTML() - вставляет указанный HTML, без перезаписи
-------------------
    targetElement.insertAdjacentHTML(position, text);

Вставляет указанный HTML в DOM дерево в указанную позицию. Данная функция не переписывает имеющиеся элементы, что предотвращает дополнительную сериализацию и поэтому работает быстрее, чем манипуляции с innerHTML.

    const textToAdd = event.target.elements.text.value;
    const div = document.getElementById("main");
    div.insertAdjacentHTML("beforeend", `<p>${textToAdd}</p>`);
---------------------------------------------------------
/// Добавление элементов с помощью функций
---------------------------------------------------------
  const createInputWithLabel = (label, inputType, inputName, placeholder) => {
    const labelContainer = document.createElement("label");
    labelContainer.innerText = label;
  
    const inputElement = document.createElement("input");
    inputElement.type = inputType;
    inputElement.name = inputName;
    inputElement.placeholder = placeholder;
  
    labelContainer.append(inputElement);
  
    return labelContainer;
  };
  
  const formContainer = document.createElement("form");
  formContainer.className = "create-user-form";

  const userNameLabel = createInputWithLabel(
    "Имя",
    "text",
    "userName",
    "Введите ваше имя"
  );    // это аргументы функции

  const passwordLabel = createInputWithLabel(
    "Пароль",
    "password",
    "password",
    "Придумайте Пароль"
  );    // это аргументы функции

  const confirmButton = document.createElement("button");
  confirmButton.type = "submit";
  confirmButton.innerText = "Подтвердить";
  
  formContainer.append(userNameLabel, passwordLabel, confirmButton);
  document.body.prepend(formContainer);
---------------------------------------------------------
/// Пропуск аргументов при вызове функции
---------------------------------------------------------
    function foo(options) {
        let arr = [
            a = options.a,
            b = options.b,
            c = options.c,
            d = options.d,
            e = options.e,
            f = options.f
        ]
        return newArr = arr.filter(el => {
            return el !== undefined
        })
    }
    const callFoo3 = foo({f: 6, c: 4});
    console.log(callFoo3);

// Грубо говоря тут говориться что: options f = 6, а options с = 4
// Сначала мы ищем по переменной параметра, а потом находим более точно по букве.
// И найденное значение запоминаем в новую переменную
-------
    function foo(options) {
        let arr = {
            a: options.a,
            b: options.b,
            c: options.c,
            d: options.d,
            e: options.e,
            f: options.f,
        }
        let newArr = []
        for (const el in arr) {
            if (arr[el] !== undefined) {
                newArr.push(arr[el])
            }
        }
        return newArr
    }
    const callFoo = foo({f: 15, c: 6});
    console.log(callFoo);
-------
    function foo(options) {
    let arr = {
        a: options.a,
        b: options.b,
        c: options.c,
        d: options.d,
        e: options.e,
        f: options.f,
    }
    let newObj = {}
    for (const el in arr) {
        if (arr[el] !== undefined) {
            newObj = {
                ...newObj,
                [el]: arr[el]
            }
        }
    }
    return newObj
    }
    const callFoo = foo({a: 15, c: 6});
    console.log(callFoo);
-------
    function fn (className, classId,type, valueText) {
        return [
            className, 
            classId, 
            type,
            valueText,
        ];
    }

    [className, id, , value] = fn('name', 1, undefined, 'TEXT!')

    let arr2 = [className, id, value]
    console.log(arr2);
// Or
    let [className, id, , value] = fn('name', 1, undefined, 'TEXT!')
    console.log([className, id, value]);
---------------------------------------------------------
//// Функция для раздачи id, классов и тд тегам
---------------------------------------------------------
    const tasksList = document.querySelector('.tasks-list');

    function giveValueTags (tag) {
        return obj = {
            valueClass: tag.i_class,
            valueType: tag.i_type,
            valueId: tag.i_id,
            valueDataId: tag.i_dataset,
            valueText: tag.i_value,
        }

    //  let newObj = {}
    //  for (const el in obj) {
    //      if (obj[el] !== undefined) {
    //          newObj = {
    //              ...newObj,
    //              [el]: obj[el]
    //          }
    //      }
    //  }
    //  return newObj // Этот фильтр не поможет, тк при запуске второй функции отсутствующие элементы все равно упоминаются и пытаются быть назначенными (что равно undefined)
    }

    const tagsTaskList = giveValueTags
    ({ 
        i_class: 'tasks-list!',
        i_value: 'TEXT!', 
        i_id: 15, 
    })

    function giveNameTag(elem) {
        // Добавил if, так фильтр не пропустит undefined элементы
        if (!!atrTaskList.valueClass) 
        elem.className = atrTaskList.valueClass;
        if (!!atrTaskList.valueType) 
        elem.type = atrTaskList.valueType;
        if (!!atrTaskList.id) 
        elem.id = atrTaskList.id
        if (!!atrTaskList.valueDataId) 
        elem.dataset = atrTaskList.valueDataId;
        if (!!atrTaskList.valueText) 
        elem.innerText = atrTaskList.valueText; 
    }
    giveNameTag(tasksList)
-------
/// Refactoring
-------
// Так же добавил исправление с добавлением имени и значения data-*
(пишем имя в формате camelCase, data-* сама ставит "-" между словами)
function giveValueAttribute (atr, elem) {
    if (!!atr.class)   elem.className = atr.class
    if (!!atr.type)    elem.type = atr.type
    if (!!atr.id)      elem.id = atr.id
    if (!!atr.value)   elem.innerText = atr.value
    if (!!atr.dataName) elem.dataset[atr.dataName] = atr.dataValue
}
giveValueAttribute({
    class:"task-item!",
    dataName: 'taskId', dataValue: '1',
},tasksItem)

-------------------
// Функция для создания, перемещения, назначения атрибута элементу
-------------------
// Заметка от куратора: старайся именовать функции, которые добавляют ноды в DOM ключевым словом render

    const tasksList = document.querySelector('.tasks-list');

    function find(selector) {
        return document.querySelector(selector);
    } // Добавил поиск по querySelector для вставки в pasteElem()

    let pasteElem, giveValueAttribute;

    function createElem (elemName, command, tag) {
        if (!!elemName) 
            elemName = document[command](tag)
        
        
        pasteElem = function (toWhom, command, whichElemPaste = elemName) {
            toWhom[command](whichElemPaste)
        }

        giveValueAttribute = function (atr, elem = elemName) {
            if (!!atr.class)    elem.className = atr.class
            if (!!atr.type)     elem.type = atr.type
            if (!!atr.id)       elem.id = atr.id
            if (!!atr.value)    elem.innerText = atr.value
            if (!!atr.dataName) elem.dataset[atr.dataName] = atr.dataValue
        } // Так же можно устанавливать аттрибуты через: 
            elem.setAttribute("id", atr.id)
    }

// Родительская функция всегда должна инициализироваться для вызова дочерних.
    createElem() 
    createElem('tasksItem', 'createElement', 'div') 

// Использовать для добавление созданный createElem() - 3й аргумент оставить пустым:  
    pasteElem(find('.tasks-list'), 'appendChild', );
 

// Если нужно вызвать добавление для отдельной переменной:  
    pasteElem(document.body, 'prepend', tasksList) 

giveValueAttribute({
    // class:"task-item",
    id: 1,
    dataName: 'taskId', dataValue: '1',
}, tasksList) 
// Изменять аттрибуты созданного createElem() - 2й аргумент оставить пустым (убрать из аргументов tasksList)
-------------------
// "Variant_2 Function" для создания/перемещения/назначения с использованием Цикла и Массива данных
-------------------
function find(selector) {
    return document.querySelector(selector);
}
let pasteElem, giveValueAttribute;

function createElem (createdElem, tag) {
    if (!!createdElem) 
        createdElem = document.createElement(tag)
    
    pasteElem = function (toWhom, command, whichElemPaste = createdElem) {
        toWhom[command](whichElemPaste)
    }

    giveValueAttribute = function (atr, elem = createdElem) {
        if (!!atr.class)    elem.className = atr.class
        if (!!atr.type)     elem.type = atr.type
        if (!!atr.id)       elem.id = atr.id
        if (!!atr.value)    elem.innerText = atr.value
        if (!!atr.dataName) elem.dataset[atr.dataName] = atr.dataValue
        if (!!atr.for)      elem.setAttribute("for", atr.for) 
    }
}

let arr = [
    tasksItem = {
        create: {a: 'tasksItem', b: 'div'},
        paste: {a: '.tasks-list', b: 'appendChild'},
        valueAtr: {
            class:"task-item",
            dataName: 'taskId', dataValue: '1',
        }
    },
    mainContainer = {
        create: {a: 'mainContainer', b: 'div'},
        paste: {a: '.tasks-list', b: 'appendChild'},
        valueAtr: {
            class:"task-item",
            dataName: 'taskId', dataValue: '1',
        }
    }
]


for (const el of arr) {
    createElem (el.create.a, el.create.b)
    pasteElem(find(el.paste.a), el.paste.b, );
    giveValueAttribute({
        class: el.valueAtr.class,
        dataName: el.valueAtr.dataName, 
        dataValue: el.valueAtr.dataValue,
    }, );
}

---------------------------------------------------------
//// Обработчики событий. 'click'
---------------------------------------------------------
/// event.target - Найти элемент, по которому сделан клик
-------------------
    const {target} = event - рекомендованная запись
    const target = event.target // Тоже самое
-------------------
/// .addEventListener() - Метод добавления обработчика событий
-------------------
    elem.addEventListener('click', (event) => {})
-------
// Добавить обработчик для одного элемента:
    const p = document.querySelector("p");
    p.addEventListener("click", (event) => {
        event.target.textContent += " клик";
    });

-------
// Добавить обработчик для нескольких элементов, необходимо пропустить их через Цикл:

    const paragraphs = document.querySelectorAll("p");
    paragraphs.forEach(p => {
        p.addEventListener("click", event => {
            event.target.textContent += " клик";
        });
    }) 
    // const {target} = event // это event.target

Однако такой многоуровневый код достаточно сложно читать, поэтому вынесем обработчик в отдельную функцию addText():

    const paragraphs = document.querySelectorAll("p");
    paragraphs.forEach(p => {
        p.addEventListener("click", addText);
    });

    function addText(event) {
        event.target.textContent += " клик";
    }
-------
// Создать переключение темы для элемента при нажатии
-------
    const allNavButton = 
        document.querySelectorAll('.main-navigation__button-item');

    allNavButton.forEach(button => {
        button.addEventListener('click', event => {
            allNavButton.forEach(button => {
                button.classList.remove
                    ('main-navigation__button-item_selected')
            });

            const {target} = event
            target.classList.add('main-navigation__button-item_selected')
        })
    });

-------------------
/// Событие 'submit'
-------------------
Элемент HTML form (<form>) — элемент позволяющий пользователю отправлять информацию на веб-сервер.

    !DOCTYPE html>
    <html>
        <head>
            <title>Пример документа</title>
        </head>
        <body>
            <form id="form">
                <input name="text" type="text" />
                <input type="submit" value="Добавить" />
            </form>
            <div id="main">
                <p class="text" data-id="1">Первый абзац</p>
                <p class="text" data-id="2">Второй абзац</p>
            </div>
            <script src="form.js"></script>
        </body>
    </html>

Найдем элемент <form> и добавим к нему обработчик события submit
    const form = document.getElementById("form");

    form.addEventListener("submit", (event) => {
    // Код обработчика
    });
В коде обработчика нам нужно реализовать следующий алгоритм:
    *Получить введённый пользователем текст из текстового поля.
    *Найти блок <div>, в который будет делаться вставка данных.
    *Вставить новый абзац (элемент <p>) в основной блок.

-------------------
//// event.preventDefault() - Отмена поведения по умолчанию 
-------------------
Отмена поведения по умолчанию 
(При 'submit' отмена перезагрузки страницы)

-------------------
//// elementForm.elements - Обращение к input у form
-------------------
    <form id="form">
        <input name="username" type="text" />
        <input type="submit" value="Добавить" />
    </form>
    <div id="main">
        <p class="text" data-id="1">Первый абзац</p>
        <p class="text" data-id="2">Второй абзац</p>
    </div>

Находим тег 'form', и для обращения например к его 'input' обращаемся 
к найденному тегу(target, если настроен).elements.имяInput.value

    const form = document.querySelector('#form')

    form.addEventListener('submit', event => {
        event.preventDefault()

        const {target} = event
        
        const enteredText = target.elements.username.value
        const div = document.getElementById('main')
        div.insertAdjacentHTML('afterbegin', `<p>${enteredText}</p>`)

    })
// Or
    const formInputs = document.getElementById("form");
    const inputByIndex = elements.formInputs[0];
    const inputByName = elements.formInputs["username"];

---------------------------------------------------------
//// Планирование: setTimeout и setInterval
---------------------------------------------------------
// setTimeout() позволяет вызвать функцию один раз через определённый интервал времени.
// setInterval() позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени
// clearInterval() отменить какой-либо таймер 

Синтаксис:
    let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...);

Параметры:
    func|code
        Функция или строка кода для выполнения. Обычно это функция. По историческим причинам можно передать и строку кода, но это не рекомендуется.
    delay
        Задержка перед запуском в миллисекундах (1000 мс = 1 с). Значение по умолчанию – 0.
    arg1, arg2…
        Аргументы, передаваемые в функцию

Например, данный код вызывает sayHi() спустя одну секунду:

    function sayHi() {
    alert('Привет');
    }
    setTimeout(sayHi, 1000);

---------
// Выводит каждый элемент через 1 сек
    let arr = [1, 2, 3, 4, 5]

    arr.forEach((el, i) => {
    setTimeout(() => {
        console.log(el)
    }, i * 1000)
    })
---------
С аргументами:

    function sayHi(phrase, who) {
    alert( phrase + ', ' + who );
    }

    setTimeout(sayHi, 1000, "Привет", "Джон"); // Привет, Джон
-------
Следующий пример выводит сообщение каждые 2 секунды. Через 5 секунд вывод прекращается:

    // повторить с интервалом 2 секунды
    let timerId = setInterval(() => alert('tick'), 2000);

    // остановить вывод через 5 секунд
    setTimeout(() => { clearInterval(timerId); alert('stop'); }, 5000);

-------------------
//// .hidden = true/false
-------------------
Мигающий элемент:
    <div id="elem">Мигающий элемент</div>

    <script>
    setInterval(() => {elem.hidden = !elem.hidden}, 1000);
    </script> // Появляется на 1 сек и пропадает на 1 сек
-------
    document.getElementById("okButton")
            .addEventListener("click", function() {
      document.getElementById("welcome").hidden = true;
      document.getElementById("awesome").hidden = false;
    }, false);

---------------------------------------------------------
/// События "keydown" и "keyup"
---------------------------------------------------------
// Нажатие и отжатие кнопки

    document.addEventListener('keydown', (event) => {
        const {key} = event
        console.log(key);

        const taskItemToDelete = document.querySelector(`[data-task-id='${key}'`);
        if (taskItemToDelete) {
            const deleteConfirm = confirm('Удалить элемент?')
            if (deleteConfirm) {
                taskItemToDelete.remove()
            }
        }
    })
-------
    document.addEventListener("keyup", (event) => {
    const key = event.key;
    const p = document.querySelector(`[data-id='${key}']`);
    if (p) {
        p.style.fontWeight = "bold";
    }
    });
---------------------------------------------------------
/// События "mouseover", "mouseout", "mousemove"
---------------------------------------------------------
// mouseover - курсор поверх элемента 
// mouseout - курсор ушел с элемента

    const paragraphs = document.querySelectorAll("p");

    paragraphs.forEach(p => {
    p.addEventListener("mouseover", (event) => {
        event.target.style.fontWeight = "bold";
    });
    });

    paragraphs.forEach(p => {
    p.addEventListener("mouseout", (event) => {
        event.target.style.fontWeight = "normal";
    });
    });

-------
    const createToolTip = (text) => {
        const tooltip = document.createElement('span');
        tooltip.textContent = text
        tooltip.className = 'tooltip'
        return tooltip
    }

    document.addEventListener('mouseover', (event) => {
        const {target} = event
        // console.log(target);
        const isOverDeleteButton = target.className.includes('task-item__delete-button')
        if (isOverDeleteButton) {
            console.log('yes');
            const taskItemHTML = target.closest('.task-item');
            const taskId = taskItemHTML?.dataset.taskId;
            if (taskId) {
                const tooltipHTML = createToolTip(`Удалить задачу №${taskId} ?`)
                target.append(tooltipHTML)
            }
        }
    });
-------
    document.addEventListener('mouseout', (event) => {
        const {target} = event
        const isOutDeleteButton = target.className.includes('task-item__delete-button')
        if (isOutDeleteButton) {
            console.log('del');
            const tooltip = document.querySelector('.tooltip');
            tooltip.remove()
        }
    });
-------
    document.addEventListener('mousemove', function (e) {
        console.log(e);
    });
---------------------------------------------------------
/// События "contextmenu", "change", "input"
---------------------------------------------------------
/// contextmenu
-------------------
Событие contextmenu срабатывает при открытии контекстного меню, то есть когда пользователь кликает правой кнопкой мыши по любой части страницы.
Это событие может пригодиться тогда, когда мы хотим сделать собственное контекстное меню вместо стандартного. Для этого нужно в обработчике отменить действие по умолчанию с помощью метода event.preventDefault():

    document.addEventListener("contextmenu", (event) => {
    event.preventDefault();
    // Дальнейший код
    });

-------------------
/// "change", "input"
-------------------
// change - срабатывает после внесенных изменений и клика вне в поля.
// input - срабатывает сразу во время введения в поле.

Будем делать кнопку "Добавить" неактивной, если пользователь ничего не ввёл:
    const button = document.querySelector("input[type='submit']");
    button.disabled = true; // По умолчанию поле пустое и кнопка неактивна

    const input = document.querySelector("input[type='text']");
    input.addEventListener("input", (event) => {
    button.disabled = !event.target.value;
    });

-------
    const checkTaskNameOnValidation = (value) => {
        if (!value || value.includes('@')) {
            return false
        }
        return true
    }

    const createTaskBlock = document.querySelector('.create-task-block')
    const createTaskBlockInput = createTaskBlock.querySelector('.create-task-block__input');

    createTaskBlockInput.addEventListener('input', (event) => {
        const {target} = event
        const {value} = target
        const isValid = checkTaskNameOnValidation(value)
        const messageError = document.querySelector('.error-message-block');

        if (!isValid) {
            const newMessageBlock = document.createElement('span')
            newMessageBlock.className = 'error-message-block';
            newMessageBlock.textContent = 'Error. The task field cannot be empty or contain a dog symbol'
            createTaskBlock.append(newMessageBlock)
        } else if (isValid && messageError) {
            messageError.remove()
        } // Если поле notValid - создает errorBlock.
        // Если введено valid - удаляет errorBlock
    });

---------------------------------------------------------
/// Всплытие и погружение. Прекращение всплытия
---------------------------------------------------------
    const allElem = document.querySelectorAll('*');

    allElem.forEach(el =>{
        el.addEventListener('click', event => {
            if (event.currentTarget.tagName === 'FORM') {
                event.stopPropagation() // Прекращение всплытия 
            }

            console.log(el.tagName);
        }, ) // Всплытие

        // el.addEventListener('click', event => {
        //     console.log(el.tagName);
        // }, true) // Если true, отслеживаем стадию погружения
    })
---------------------------------------------------------
/// Обработчики событий. Делегирование событий
---------------------------------------------------------
Делегирование события заключается в том, что вместо добавления однотипных обработчиков события для каждого элемента, мы добавляем один обработчик для родительского элемента.
  Тк добавление множества однотипный обработчиков усугубляет производительность 

    const mainNav = document.querySelector('.main-navigation');

    mainNav.addEventListener('click', function (event) {
        const {target} = event
        const button = target.closest('.main-navigation__button-item')
        if (button) {
            button.style.color = 'red'
            setTimeout(() => {
                button.style.color = 'white'
            }, 1000)
        }
    });
Делегирование событий возможно благодаря технологии распространения событий, которую мы рассмотрели ранее.
-------
    table.onclick = function(event) {
    let td = event.target.closest('td'); // (1)

    if (!td) return; // (2)

    if (!table.contains(td)) return; // (3)

    highlight(td); // (4)
    };

(1) Метод elem.closest(selector) возвращает ближайшего предка, соответствующего селектору. В данном случае нам нужен <td>, находящийся выше по дереву от исходного элемента.
(2) Если event.target не содержится внутри элемента <td>, то вызов вернёт null, и ничего не произойдёт.
(3) Если таблицы вложенные, event.target может содержать элемент <td>, находящийся вне текущей таблицы. В таких случаях мы должны проверить, действительно ли это <td> нашей таблицы.
(4) И если это так, то подсвечиваем его.

(1-2) Пояснение elem.closest(selector). Когда мы кликаем на элемент к которому назначен поиск по родству, мы проверяем принадлежит ли он данной группе элементов, так же он может возвращать сам себя. Так мы устанавливаем что это нужный нам элемент

---------------------------------------------------------
//// Async/await - асинхронные функции
---------------------------------------------------------
// async - делает функцию асинхронной.
---------
И async function() всегда возвращает промис. Значения других типов оборачиваются в завершившийся успешно промис автоматически.

	async function f() {
	    return 1;
	}

	f().then(alert); // 1

Можно и явно вернуть промис, результат будет одинаковым:

	async function f() {
	    return Promise.resolve(1);
	}

	f().then(alert); // 1

---------
// await - ожидание готовности результата promise
---------
Синтаксис:
	let value = await promise;

Ключевое слово await заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от await не выполнится. После чего оно вернёт его результат, и выполнение кода продолжится.

Ключевое слово – await работает только внутри async–функций

В этом примере промис успешно выполнится через 1 секунду:

	async function f() {
		let promise = new Promise((resolve, reject) => {
			setTimeout(() => resolve("готово!"), 1000)
		});

		let result = await promise; // будет ждать, пока промис не выполнится 
		alert(result); // "готово!"
	}
	f();

---------
// await нельзя использовать в обычных функциях
---------
	function f() {
	let promise = Promise.resolve(1);
	let result = await promise; // SyntaxError
	}

Ошибки не будет, если мы укажем ключевое слово async перед объявлением функции. Как было сказано раньше, await можно использовать только внутри async–функций.
---------
// await нельзя использовать на верхнем уровне вложенности 
	(вне тела функции)
---------
Можно обернуть этот код в анонимную async–функцию, тогда всё заработает:
	(async () => {
		let response = await fetch('/article/promise-chaining/user.json');
		let user = await response.json();
		...
	})();
---------------------------------------------------------
//// Асинхронность (Promise + Fetch)
---------------------------------------------------------
/// Объект Promise - уведомляет запрашивающие части о результате выполненного кода. 
    Сервер <---Гонец с результатами---> Запрашивающий код
-------------------
Promise (по англ. promise - обещать) – это специальный объект в JavaScript, который связывает «создающий» и «потребляющий» коды вместе. В терминах нашей аналогии – это «подписка на уведомления от автора». «Создающий» код может выполняться сколько потребуется, чтобы получить результат, а промис делает результат доступным для кода, который подписан на него, когда результат готов.

Синтаксис Promise:
	let promise = new Promise(function(resolve, reject) {
	// функция-исполнитель (executor) - // "певец"
	});
	
Функция, переданная в конструкцию new Promise, называется исполнитель (executor). Когда Promise создаётся, она запускается автоматически. Она должна содержать «создающий» код, который когда-нибудь создаст результат. В терминах нашей аналогии: исполнитель – это «певец».

Когда код получает результат, сейчас или позже – не важно, он должен вызвать один из этих колбэков:
   resolve(value) — если работа завершилась успешно, value – результат.
   reject(error) — если произошла ошибка, error – объект ошибки.

Итак, исполнитель запускается автоматически, он должен выполнить работу, а затем вызвать resolve или reject.

У объекта promise, возвращаемого конструктором new Promise, есть внутренние свойства:

   state («состояние»): 
	0) Вначале "pending" («ожидание»)
		1) Затем, в случае успеха вызывается: "resolve". И статус меняется на "fulfilled" («выполнено успешно»).
		2) В случае неудачи вызывается "reject". И статус меняется на "rejected" («выполнено с ошибкой»)
	
Три статуса Promise:
	pending - ожидание
	fulfilled - удачное выполнение promise
	rejected - выполнение promise с ошибкой

	result («результат»):
	0) Вначале "undefined":
		1) Далее изменяется на value при вызове resolve(value) 
		2) Или изменяется на error при вызове reject(error) 

-------------------
// Вызвано может быть что-то одно: 
	 либо результат(resolve)
	 либо ошибка(reject)
-------------------
Исполнитель должен вызвать что-то одно: resolve или reject. Состояние промиса может быть изменено только один раз.
Все последующие вызовы resolve и reject будут проигнорированы:

	let promise = new Promise(function(resolve, reject) {
		resolve("done");

		reject(new Error("…")); // игнорируется
		setTimeout(() => resolve("…")); // игнорируется
	});
Идея в том, что задача, выполняемая исполнителем, может иметь только один итог: результат или ошибку.

Также заметим, что функция resolve/reject ожидает только один аргумент (или ни одного). Все дополнительные аргументы будут проигнорированы.
---------
// Вызывайте "reject" с объектом new Error("…")
---------
В случае, если что-то пошло не так, мы должны вызвать reject. Это можно сделать с аргументом любого типа (как и resolve), но рекомендуется использовать объект Error

-------------------
/// Потребители: then, catch
-------------------
Объект Promise служит связующим звеном между исполнителем («создающим» кодом или «певцом») и функциями-потребителями («фанатами»), которые получат либо результат, либо ошибку. Функции-потребители могут быть зарегистрированы (подписаны) с помощью методов .then и .catch
---------
// .then( fResult(){}, fError(){} ) - наиболее важный метод
---------
Синтаксис:
	promise.then(
		function(result) { /* обработает успешное выполнение */ },
		function(error) { /* обработает ошибку */ }
	);

1) Первый аргумент метода .then – функция, которая выполняется, когда промис переходит в состояние «выполнен успешно», и получает результат.
2) Второй аргумент .then – функция, которая выполняется, когда промис переходит в состояние «выполнен с ошибкой», и получает ошибку.

Если мы хотели бы только обработать ошибку, то можно использовать null в качестве первого аргумента: 
	.then(null, errorHandlingFunction => {new Error('Error message')})

---------
	const variable = true

	let promise = new Promise(function(resolve, reject) {
		if (variable) {
			setTimeout(() => resolve("done!"), 1000);
		} else {
			setTimeout(() => reject(new Error("Whoops!")), 1000);
		}
	});

	promise.then(
		result => alert(result), // выведет "done!" через одну секунду
		error => alert(error) // не будет запущена
	);  // resolve запустит первую функцию, переданную в .then
 
---------
// .catch(fError) – это сокращённый вариант .then(null, f)
---------
Если мы хотели бы только обработать ошибку, то можно использовать null в качестве первого аргумента: .then(null, errorHandlingFunction). 
Или можно воспользоваться методом .catch(errorHandlingFunction), который сделает то же самое:

	let promise = new Promise((resolve, reject) => {
	setTimeout(() => reject(new Error("Ошибка!")), 1000);
	});

	// .catch(f) это то же самое, что promise.then(null, f)
	promise.catch(alert); // выведет "Error: Ошибка!" спустя одну секунду

---------
// .finally() – выполнится в любом случае, когда промис завершится: успешно или с ошибкой.
---------
Идея finally состоит в том, чтобы настроить обработчик для выполнения очистки/доведения после завершения предыдущих операций.
 Например, остановка индикаторов загрузки, закрытие больше не нужных соединений и т.д.

	new Promise((resolve, reject) => {
		/* сделать что-то, что займёт время, и после вызвать resolve или может reject */
	})
		.finally(() => остановить индикатор загрузки)
		  // выполнится, когда промис завершится, независимо от того, успешно или нет

		.then(result => показать результат, err => показать ошибку)
		  // таким образом, индикатор загрузки всегда останавливается, прежде чем мы продолжим

Есть важные различия:
 1) Обработчик, вызываемый из finally, не имеет аргументов.
 2) Обработчик finally «пропускает» результат или ошибку дальше, к последующим обработчикам.
 
Например, здесь результат проходит через finally к then:

	new Promise((resolve, reject) => {
		setTimeout(() => resolve("value"), 2000);
	})
		.finally(() => alert("Промис завершён")) // срабатывает первым
		.then(result => alert(result)); // <-- .then показывает "value"

 3) Если обработчик finally возвращает что-то, это игнорируется.
	Когда finally выдает ошибку, выполнение переходит к ближайшему обработчику ошибок.

---------
Чтобы получить данные которые мы передавали в resolve, reject, необходимо обработать наш promise с помощью: then / catch / finally

	const promise = new Promise ((resolve, reject) => {
		if (developer.isJSDev) {
			setTimeout(() => {
				resolve(`${developer.name} - JS developer`);
			}, 3000)
		} else {
			reject(`${developer.name} - Not a JS developer`);
		}
	})
	console.log(promise);

	promise
		.then((successMessage) =>{ 
			// Обрабатывает успешное выполнение promise
			console.log(successMessage);
		})
		.catch((error) => { 
			// Принимает в себя ошибку от и позволяет двигаться коду дальше 
			console.log(error);
		})
		.finally(() => { 
			// Вызовется, когда promise будет выполнен (вне зависимости успешно или с ошибкой)
			console.log(`finally message`);
		})
-------
	promise
		.then((result) => {
			console.log(result); // Всё хорошо, можно ехать!
		})
		.catch((error) => {
			console.log(error);  // Нужно заправиться
		});
Более которая форма записи 
	promise
		.then(console.log)   // Всё хорошо, можно ехать!
		.catch(console.log); // Нужно заправиться
---------------------------------------------------------
//// fetch() - функция для получение данных с сервера по url
---------------------------------------------------------
Метод fetch() позволяет получать данные по сети асинхронно (то есть он возвращает объект Promise).

Cинтаксис:
	let promise = fetch(url, [options])
		url – URL для отправки запроса.
		options – дополнительные параметры: метод, заголовки и так далее.

Без options это простой GET-запрос, скачивающий содержимое по адресу url.

	const createTodoElement = (text) => {
		const todoElem = document.createElement('li');
		const todoElemAnchor = document.createElement('a');
		todoElemAnchor.href = '#'
		todoElemAnchor.textContent = text;
		todoElem.append(todoElemAnchor)

		return todoElem
	}
	const toggleLoader = () => {
		const loaderHTML = document.querySelector('#loader');
		const isHidden = loaderHTML.hasAttribute('hidden')
		if (isHidden) {
			loaderHTML.removeAttribute('hidden')
		} else {
			loaderHTML.setAttribute('hidden', '')
		}
	}

	const dataContainer = document.querySelector('#data-container');

	const getAllTodoes = () => {
		toggleLoader();
		fetch('https://jsonplaceholder.typicode.com/todos', {
		method: 'GET', // GET, POST, DELETE..
	})
		.then((responseValue) => {
			if (!responseValue.ok) { 
				// ok - произошел ли запрос успешно 
				throw new Error('Ошибка запроса'); 
				// throw - выбрасывает ошибку и переводит в блок .catch()
			}
			return responseValue.json(); 
			// декодирование запроса
		})
		.then((todoes) => { 
			// передаем дальше декодированный запрос
			todoes.forEach((el, i, arr) => {
				const todoHTML = createTodoElement(el.title);
				dataContainer.append(todoHTML);
			});
		})
		.catch((error) => {
			console.log('error:', error);
		})
		.finally(() => {
			toggleLoader();
		})
	};
	getAllTodoes()

---------
	fetch("https://api.github.com/users")
		.then((response) => {
			if (!response.ok) {
				throw new Error("Ошибка запроса");
			}
		return response.json();
		})
		.then((data) => {
			outputTable(data);
		})
		.catch((error) => {
			console.log(error);
		})
		.finally(() => {
			const loader = document.getElementById("loader");
			loader.style.display = "none";
		});

	function outputTable(users) {
		const table = document.createElement("table");
		for (const user of users) {
			const row = table.insertRow();

			const column1 = row.insertCell();
			column1.innerHTML = `<img class="avatar" src="${user.avatar_url}" />`;

			const column2 = row.insertCell();
			column2.innerHTML = `<a href="${user.html_url}">${user.login}</a>`;
		}
		document.body.append(table);
	}
---------------------------------------------------------
//// "try..catch" - обработка ошибок 
---------------------------------------------------------
Конструкция try..catch, позволяет «ловить» ошибки и вместо падения делать что-то более осмысленное. 

Синтаксис «try…catch»:

Конструкция try..catch состоит из двух основных блоков: try, и затем catch:
	try {
		// код...
	} catch (err) {
		// обработка ошибки
	}

1) Сначала выполняется код внутри блока try {...}.
2) Если в нём нет ошибок, то блок catch(err) игнорируется: выполнение доходит до конца try и потом далее, полностью пропуская catch.
3) Если же в нём возникает ошибка, то выполнение try прерывается, и поток управления переходит в начало catch(err). Переменная err (можно использовать любое имя) содержит объект ошибки с подробной информацией о произошедшем.

Пример с ошибками: выведет (1) и (3):
	try {
		alert('Начало блока try');  // (1) <--
		undefinedVariable; // ошибка, переменная не определена!
		alert('Конец блока try (никогда не выполнится)');  // (2)
	} catch(err) {
		alert(`Возникла ошибка!`); // (3) <--
	}

---------
// try..catch работает синхронно
---------
Исключение, которое произойдёт в коде, запланированном «на будущее», например в setTimeout, try..catch не поймает:

	try {
		setTimeout(function() {
			noSuchVariable; // скрипт упадёт тут
		}, 1000);
	} catch (e) {
		alert( "не сработает" );
	}

Это потому, что функция выполняется позже, когда движок уже покинул конструкцию try..catch.

Чтобы поймать исключение внутри запланированной функции, try..catch должен находиться внутри самой этой функции:

	setTimeout(function() {
		try {
			noSuchVariable; // try..catch обрабатывает ошибку!
		} catch {
			alert( "ошибка поймана!" );
		}
	}, 1000);

---------
// throw - выбрасывает ошибку и переводит в блок .catch()

---------------------------------------------------------
//// Promise.all() - метод для обработки нескольких Promise
---------------------------------------------------------
Метод Promise.all() позволяет дождаться выполнения нескольких промисов и получить результат в виде массива. 
Возвращает rejected - если есть хотя бы одна ошибка   

Каждый Promise - это Объект
Promise.all() возвращает новый промис, который завершается с массивом результатов из всех входных промисов. Если вы пытаетесь использовать метод `map` на этом объекте, то вы получите ошибку, так как `map` может использоваться только с массивами. 
То есть Promise.all() не может работать с `map` до тех пор, пока не выполнится полностью. А чтобы он выполнился необходим `await`

Чтобы исправить эту ошибку, вы должны дождаться завершения промиса (получив результат или ошибку) с помощью `await` или `.then()` и затем использовать метод `map` на результирующем массиве.

Так же `await` позволяет дождаться получения массива данных, а не его промиса.
Например здесь:
    const albums = await response.json() 
Если же писать без `await`, то данные тоже придут, но в виде необработанного промиса, а нам нужен готовый массив.

Синтаксис метода:
    const arrPromises = Promise.all([ promise1, promise2, /* и т.д. */ ]);

    Promise.all()[
    	new Promise(),
    	new Promise(),
    	new Promise()
    ]

Promise.all() возвращает:
    fulfilled - если все выполнены успешно 
    rejected - если есть хотя бы одна ошибка  

---------
    const TASKS_URL = 'https://jsonplaceholder.typicode.com/todos'
    const tasksIds = [1, 41, 20, 100, 50, 1]
    const dataContainer = document.querySelector('#data-container');

    const createTodoElement = (text) => {
        const todoElem = document.createElement('li');
        const todoElemAnchor = document.createElement('a');
        todoElemAnchor.href = '#';
        todoElemAnchor.textContent = text;
        todoElem.append(todoElemAnchor);

        return todoElem
    }

// requests - Запросы
// responses - Ответы

    const getTasksById = (ids) => {       
        // requests - Массив Promise-ов, которые содержат необработанные запросы по выбранным id задач.
        const requests = ids.map((id) => fetch(`${TASKS_URL}/${id}`))

        // Обрабатываем массив с из 6-ти Promise с помощью Promise.all().
        Promise.all(requests)
            // Обрабатываем Promise.all
            .then((responses) => {
                // Декодируем КАЖДЫЙ Promise и помещаем в новый массив.
                // Тк можно считать что Promise.all - массив для промисов. А массив нужно перебрать, для применения к каждому el.
                dataResults = responses.map((response) => response.json()) 
                
                // dataResults - массив декодированных Promise-ов, для работы с ним возвращаем массив в Promise.all().
                 // Если не передать результат через "return", то следующий "then" не получит данных для обработки 
                return Promise.all(dataResults)	
            })
            .then((tasks) => {
                tasks.forEach(el => {
                    tasksHTML = createTodoElement(el.title)
                    dataContainer.append(tasksHTML)
                });
            })
            .catch((error) => {
                console.log(error);
            })
    }
    getTasksById(tasksIds)
---------------------------------------------------------
//// Promise.race() - возвращает результат самого быстрого промиса
---------------------------------------------------------
Promise.race() - как и Promise.all() принимает в себя массив промисов. Возвращает результат Promise-а (независимо resolve || reject) который выполнился первым 

Синтаксис метода:
    const promise = Promise.race([
        new Promise(),
        new Promise(),
        new Promise(),
    ])

    const promise1 = new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve('promise1')
        }, 500)
    })
    const promise2 = new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve('promise2')
        }, 2000)
    })
    const promise3 = new Promise((resolve, reject) => {
        setTimeout(() => {
            reject('promise3')
        }, 100)
    })

    Promise.race([promise1, promise2, promise3])
        .then((result) => {
            console.log('result', result);
        })
        .catch((error) => {
            console.log('error', error);
        })

---------------------------------------------------------
//// Асинхронность (async/await) рекомендуется вместо .then()
---------------------------------------------------------
/// Ключевое слово async
-------------------
Ключевое слово "async" позволяет удобным способом создавать асинхронные функции. Async перед функцией гарантирует, что эта функция вернёт промис

Два аналогичных примера:

    const sum = async () => {
    return 2 + 2;
    }

    function sum() {
        return new Promise((resolve, reject) => {
            resolve(2 + 2);
        });
    }

Поскольку асинхронная функция всегда возвращает промис, для обработки результата используется конструкция then:

    sum().then(result => {
        console.log(result); // Выведет 4
    })

-------------------
/// Ключевое слово await
-------------------
Ключевое слово await используется, чтобы дождаться выполнения асинхронной операции справа от await и вернуть его результат:

    const result = await promise;

Например, в следующем примере с помощью await мы ждем результат промиса и выводим его в консоль:

    async function test() {
        const promise = new Promise(resolve => {
            setTimeout(() => resolve("Успех"), 1000);
        });
        const result = await promise;
        console.log(result);
    }
    test(); // "Успех"
Аналогичный результат можно получить и с помощью Promise.then(), однако await позволяет получить результат промиса более компактным и наглядным способом.

-------------------
/// Обработка ошибок
-------------------
Обработать ошибки внутри async функций можно двумя способами:
    * С помощью блоков try/catch внутри самой функции.
    * С помощью метода Promise.catch() на верхнем уровне при обработке результата функции.

    async function getData() {
        try {
            const result = await promise;
            return result;
        } 
        catch(error) {
            console.error("Ошибка! " + error);
        }
    }
---------
    async function getData() {
        const result = await promise;
        return result;
    }

    getData()
        .then(result => {
            // Обработка результата
        })
        .catch(error => {
            console.error("Ошибка! " + error);
    });

---------
    <!DOCTYPE html>
    <html>
        <head>
            <title>Пример async/await</title>
        </head>
        <body>
            <span id="loader">Загрузка...</span>
            <h1 id="header"></h1>
            <img id="image">
            <script src="index.js"></script>
        </script>
        </body>
    </html>

    function getRandomArrayElement(array) {
        const randomIndex = Math.floor(Math.random() * array.length);
        return array[randomIndex];
    }

    async function getCat() {
        // Получаем список тегов
        const tagsResponse = await fetch("https://cataas.com/api/tags");
        const tags = await tagsResponse.json();

        // Выбираем случайный тег
        const randomTag = getRandomArrayElement(tags);

        // Получаем котиков по тегу
        const catsResponse = await fetch(
            `https://cataas.com/api/cats?tags=${randomTag}`
        );
        const cats = await catsResponse.json();

        // Выбираем случайного котика
        const randomCat = getRandomArrayElement(cats);

        // Формируем результат
        return {
            tag: randomTag,
            url: `https://cataas.com/cat/${randomCat.id}`
        };
    }

    getCat()
        .then((result) => {
            // Выводим заголовок
            const header = document.getElementById("header");
            header.textContent = result.tag;

            // Выводим картинку
            const image = document.getElementById("image");
            image.src = result.url;
        })
        .catch(console.error)
        .finally(() => {
            // Скрываем статус загрузки
            const loader = document.getElementById("loader");
            loader.style.display = "none";
        });
Вообще, совмещение двух подходов — это нормально и зачастую они используются вместе.

---------
    const getTodosWithUserData = async () => {
        try {
            const response = await fetch(USERS_URL) // Функция не пойдет дальше пока код не выполниться 
            if (!response.ok) {
                throw new Error('Ошибка запроса пользователя')
            }
            const users = await response.json()
            const firstUserId = users[0]?.id; // Это синхронный вызов, await не нужен
            const todosResponse = await fetch(`${TODOS_URL}?userId=${firstUserId}`)
            if (!todosResponse.ok) {
                throw new Error('Ошибка запроса задач')
            }
            const todos = await todosResponse.json()
            console.log('todos:', todos);
        } catch (error) {
            console.log(error);
        } finally {
            console.log("finally");
        }
    };

    getTodosWithUserData()
---------------------------------------------------------
//// Вызвать функцию с помощью Объекта 
---------------------------------------------------------
    const calculateTotalMortgage = 
    (percent, contribution, amount, countMonth) => {
        console.log(percent+contribution+amount+countMonth);
    }

    const calculatorArguments = [    
        [10, 0, 50000, 12],
        [10, 1000, 50000, 12],
        [10, 0, 20000, 24],
        [10, 1000, 20000, 24],
        [10, 20000, 20000, 24],
        [10, 0, 10000, 36],
        [15, 0, 10000, 36]
    ]

    calculatorArguments.forEach(el => {
        let obj = {};
        el.forEach((val, i) => {
            obj[`arg${i}`] = val;
        });
        calculateTotalMortgage(obj.arg0, obj.arg1, obj.arg2, obj.arg3);
    });
---------------------------------------------------------
//// isNaN() - Аналог typeof, но с попыткой преобразования значения. Выводит так же true/false
---------------------------------------------------------
!!! Не используй в сравнении x === NaN. Нифига не получиться. 
Используй для этого isNaN()

    console.log(NaN === NaN); // false
    console.log(isNaN(NaN)); // true

Метод isNaN пытается преобразовать переданный параметр в число. Если параметр не может быть преобразован, возвращает true, иначе возвращает false.
Эта функция полезна, так как значение NaN не может быть проверено операторами эквивалентности.

То есть, если значение not a number, то выдает true, иначе false.
Пример

isNaN(NaN);       // true
isNaN(undefined); // true
isNaN({});        // true

isNaN(true);      // false
isNaN(null);      // false
isNaN(37);        // false

// strings
isNaN("37");      // false: "37" преобразуется в число 37 которое не NaN
isNaN("37.37");   // false: "37.37" преобразуется в число 37.37 которое не NaN
isNaN("");        // false: пустая строка преобразуется в 0 которое не NaN
isNaN(" ");       // false: строка с пробелом преобразуется в 0 которое не NaN
isNaN("37,5");    // true

// Даты
isNaN(new Date());                // false
isNaN(new Date().toString());     // true

// Пример почему использование isNaN не всегда уместно
isNaN("blabla")   // true: "blabla" преобразовано в число.
    
---------------------------------------------------------
//// Как сократить количество параметров функции?
---------------------------------------------------------
Можно использовать объект в качестве аргумента. 
Вместо передачи нескольких переменных в функцию можно передать один объект, содержащий все необходимые параметры.

    const calculateTotalMortgage = (params) => {
        const percent = params.percent;
        const contribution = params.contribution;
        const amount = params.amount;
        const countMonth = params.countMonth;
        // далее идет основной код функции
    }
---------
    const calculateTotalMortgage = (params) => {
        const percent = params.arg0
        const contribution = params.arg1
        const amount = params.arg2
        const countMonth = params.arg3

        console.log( percent+contribution+amount+countMonth );
    }

    const mortgageValues = [    
        [10, 0, 50000, 12],
        [10, 1000, 50000, 12],
        [10, 0, 20000, 24],
        [10, 1000, 20000, 24],
        [10, 20000, 20000, 24],
        [10, 0, 10000, 36],
        [15, 0, 10000, 36]
    ]

    mortgageValues.forEach(el => {
        let obj = {};
        el.forEach((val, i) => {
            obj[`arg${i}`] = val;
        });
        calculateTotalMortgage(obj);
    });
---------------------------------------------------------
//// Callback-hell - Ад коллбеков
---------------------------------------------------------
Используя коллбэки по-крупному, мы рискуем получить так называемый “ад коллбэков”.

Наглядно это выглядит так:
    setTimeout(() => {
    setTimeout(() => {
        setTimeout(() => {
        setTimeout(() => {
            console.log('Hello World!')
        }, 1000)
        }, 1000)
    }, 1000)
    }, 1000)

Таким образом, наш код растет вправо. Решить такую проблему можно с помощью Promise.

    const FIRST_TODO_URL = 
    'https://jsonplaceholder.typicode.com/todos/1';

    const getTodo = (callback) => {
        fetch(FIRST_TODO_URL)
            .then((response) => response.json())
            .then((todo) => {
                // console.log(todo)
                callback(todo)
            })
            .catch((error) => {
                console.log(error)
            })
    }
    getTodo((todoItem) => {
        console.log(todo)
    })

---------------------------------------------------------
//// Event Loop - цикл событий: 
     Callback Stack, Microtask Queue, Callback Queue
---------------------------------------------------------
1) Callback Stack - первый пришел — последний ушел (стакан)
2) Microtask Queue - первый пришел — первый ушел (очередь)
3) Callback Queue - первый пришел — первый ушел (очередь)

Event Loop как прошелся по всему Callback Stack и достиг последней строчки идет смотреть Callback Queue.
Если он обнаруживает там элемент, то он закидывает его в Callback Stack

---------
/// Web API - сущности которы предоставляет нам Браузер.
---------
setInterval, setInterval - на самом деле нет в JS, это Web API браузера

---------
/// Microtask Queue (микрозадачи) - это код в then, catch, finally
---------
Существуют мАкрозадачи и мИкрозадачи.

Более приоритетная очередь чем Callback Queue - это Microtask Queue (очередь микрозадач)

Приоритет:
1) мАкрозадачи - Основной вектор движения выполнения кода от первой строчки к последней.
   // После того как движок достиг последней сточки, выполнив все main-задачи, идет смотреть:
2) мИкрозадачи - все что есть в очереди мИкрозадач
   // Если в микрозадачах что-то есть, то добавляет в Callback Stack и выполняет. Если нет или закончились, то проверяет:
3) Callback Queue - все что есть в очереди Callback Queue
   // Если там есть задачи, то так же удаляет ее из очереди, добавляет в Callback Stack, вызывает и удаляет как отработанную 

   // Как только появляется новая мАкрозадача, цикл повторяется 
---------
    console.log('start macrotask');
    console.log('performing macrotask...');

    setTimeout(() => { // Callback queue
        console.log('timeouted');
    }, 0);

    const promise = new Promise((resolve) => {
        // Этот текст выведется при вызове then
        resolve('result from promise');
    });

    promise.then((result) => { // Microtask queue
        console.log(result);
    })

    console.log('end macrotask');

    // Вывод:
    // start macrotask
    // performing macrotask...
    // end macrotask
    // result from promise
    // timeouted

    * В данном примере движок JavaScript сначала начинает главную макрозадачу – обычное синхронное выполнение скрипта.
    * Дойдя до setTimeout(), он отправит её на обработку в Web API. Затем, когда обработка завершится, переданный callback будет отправлен в Callback queue.
    * Дойдя до промиса, он его обработает, выполнит, а затем callback из then() поместит в Microtask queue.
    * Затем закончит выполнение первой макрозадачи.
    * Затем движок проверит очередь микрозадач и выполнит их по очереди, если таковые имеются. В данном случае вызовет callback из then().
    * После микрозадачи он перейдет к выполнению оставшейся макрозадачи из очереди задач. В данном случае вызовет callback из setTimeout().

---------
    setTimeout(() => {
        console.log("№4 setTimeout"); // Вызывается в callback очереди
    }, 0);

    const promise = new Promise((resolve) => {
        console.log("№1 Promise"); // Вызывается в main очереди
        resolve();
    });

    promise.then(() => {
        console.log("№3 Promise resolve"); // Вызывается в micro очереди
    });

    console.log("№2 End"); // Вызывается в main очереди

    // №1 Promise
    // №2 End
    // №3 Promise resolve
    // №4 setTimeout

---------
function runCode() {
    console.log("№1 before promise");

    return new Promise((resolve) => { // Обещает вернуть ответ когда код выполнится
        setTimeout(() => { // setTimeout переходит в буфер ожидания Callback Queue, после setTimeout(console.log("Zero"))
        // Далее код идет выполнять main-задачи, в частности console.log("One"). Как только main-задачи закончились, движок проверяет какие задачи готовы к выполнению (чьи таймеры закончились). 
        // Первым в очереди Callback Queue стоял clg("Zero") и тк время ожидания таймеров у нас одинаково, то он сохраняет свою очередь и идет первым к исполнению. Оболочка таймера раскрывается и clg("Zero") попадает в Стакан Вызовов, где и реализуется, отображая в консоли "Zero"
        // Далее в очереди стоял данный промисовский setTimeout(). Тк его таймер так же равен первому, но пришел он в очередь вторым, то и выполняется он вторым, после "Zero", то есть сейчас. 
        // Оболочка таймера так же раскрывается и первым движок видит console.log("№ Zero Promise"), после чего помещает его в Стакан Вызовов, где тот и исполняется, выводя сообщение "Zero Promise".
            console.log("№4 Zero Promise"); 
            resolve(); // После, в раскрытом таймере видит resolve(). Видит что это Microtask и переводит его в очередь Microtask Queue. Тк микротасков нет, эта задача становится там первой и от туда сразу же перемещается в Стакан Вызовов, где и исполняется с помощью обработчика .then(), выводя в консоль сообщение "Zero Promise Invoked"
        }, 0);
    });
}

    setTimeout(() => {
        console.log("№3 Zero");
    }, 0);

    runCode()
        .then(() => console.log("№5 Zero Promise Invoked"));

    console.log("№2 One");
    // Zero

---------------------------------------------------------
//// Webpack, Rollup
---------------------------------------------------------
"./" - корневая папка файла, то где файл лежит
"../" - выйти из текущей паки на уровень выше

Особенности Rollup:
---------
// Tree shaking:
Rollup имеет интересную возможность, которая называется Tree Shaking. При сборке весь неиспользуемый код исключается, чтобы сократить размер выходного файла.

Например если мы убрали вызов функции, он уберет всю неактивную функцию.

---------
1) Инициализируем проект перед началом работы:
    $ npm init -y

Создастся package.json. 
Это файл конфигурации проекта, который применяется npm для управления настройками проекта и пакетами приложения. 

2) Установка сборщика Rollup:
    $ sudo npm install --global rollup

3) Создадим файл конфигурации Rollup rollup.config.js:
    export default {
        input: './index.js',
        output: {
            file: './build/bundle.js',
            format: 'cjs'
        }
    };

4) Сборка/Пересборка проекта
    $ rollup -c --bundleConfigAsCjs

1.2) Или вместо пункта 2) 3) выполнить:
    $ rollup ./index.js --file ./build/bundle.js --format cjs

---------
Установка дополнительных пакетов для сборки Rollup:

1) Babel - конвертирует новый синтаксис JavaScript в старый. 
@rollup/plugin-babel 
    $ npm install -D @rollup/plugin-babel @babel/preset-env

После установки откроем файл package.json и убедимся, что в него добавилась секция devDependencies со списком установленных пакетов:
    {
        "name": "code",
        "version": "1.0.0",
        "description": "",
        "main": "index.js",
        "scripts": {},
        "keywords": [],
        "author": "",
        "license": "ISC",
        "devDependencies": {
            "@rollup/plugin-babel": "^5.3.1",
            "@babel/preset-env": "^7.18.10"
        }
    }

Чтобы Rollup использовал Babel при сборке, нужно также внести изменения в конфиг rollup.config.js:

    import { babel } from '@rollup/plugin-babel';

    export default {
        input: './index.js',
        output: {
            file: './build/bundle.js',
            format: 'cjs'
        },
        plugins: [
            babel({
            babelHelpers: "bundled",
            presets: ["@babel/env"]
            }),
        ]
    };
Для проверки работы плагина добавим в наш index.js файл какой-нибудь код, которого не было в более ранних версиях языка. Например, используем стрелочную функцию в методе map():
    const array = [1, 2, 3].map(n => n + 1);
    console.log(array);
    
---------
2) Плагин для работы со стилями:
rollup-plugin-styles
    $ npm install -D rollup-plugin-styles

Затем добавим информацию о плагине в конфиг Rollup rollup.config.js. 

    import styles from "rollup-plugin-styles";
    styles()

После добавления плагина мы можем импортировать CSS-файлы в коде. 
То есть вместо добавления ссылки в HTML-документе, как мы делали ранее, в начале скрипта index.js добавим инструкцию import и название CSS-файла:

!!!   import "../index.css";

    function hello() {
        console.log("Hello world!");
    }
    hello();

---------
3) Плагин для работы с картинками:
@rollup/plugin-image
    $ npm install @rollup/plugin-image --save-dev

Далее обновим конфиг rollup.config.js, добавим в него:

    import image from "@rollup/plugin-image"; 
    image() 

Для тестирования возьмём любую картинку и положим её в папку assets нашего проекта. Далее в index.js напишем код добавления картинки на страницу. Он включает инструкцию import с путём до нашей картинки, а также добавление элемента img на страницу:

    import "./index.css";
    import MY_IMAGE from './assets/image.png';

    // Остальной код

    const img = document.createElement("img");
    img.src = MY_IMAGE;
    document.body.append(img);

Если после сборки открыть выходной файл build/bundle.js, то можно обратить внимание, что наша картинка представлена в коде в виде base64-строки. Такой подход хорошо работает для маленьких картинок, но для больших лучше использовать обычный подход с указанием ссылки на картинку (без импорта).

---------
4) Локальный сервер
rollup-plugin-serve
    $ npm install -D rollup-plugin-serve 

Обновим конфиг rollup.config.js, добавив в него:

    import serve from 'rollup-plugin-serve' 
    serve({
          open: true, 
            // Авт-ки открывает стр в браузере при запуске проекта
          contentBase: './', 
            // Директория откуда будут браться файлы 
          port: 8000,
        }),

        Функция serve() принимает объект с параметрами, которые описаны в документации. Пока оставим все параметры по умолчанию, изменим только параметр open на true, чтобы при сборке наша страницу сразу открывалась в браузере.

Запустим сборку проекта с помощью команды rollup -c и убедимся, что наша страница открывается в браузере по адресу http://localhost:10001/ (если мы не указали другой порт в настройках плагина).

---------
5) Автоматическое применение изменений
rollup-plugin-livereload
    $ npm install -D rollup-plugin-livereload

Обновим конфиг rollup.config.js, добавив в него:

    import livereload from 'rollup-plugin-livereload' 
    livereload() 

Для отслеживания изменений в исходном коде запустим сборку с дополнительным флагом -w (watch). При необходимости перед этим отключим локальный сервер с помощью сочетания клавиш Ctrl+C, чтобы иметь возможность ввести команду в терминале:
    $ rollup -c -w --bundleConfigAsCjs
    
    // npm run dev
    // npm run prod
---------------------------------------------------------
//// Array.from - создаёт новый массив из итерируемого объекта. Имеет в себе функцию map
---------------------------------------------------------
Синтаксис:
    Array.from(object, mapFn, thisArg)

object
    Массивоподобный или итерируемый объект, преобразуемый в массив.
mapFn 
    Отображающая функция, вызываемая для каждого элемента массива.
thisArg 
    Значение, используемое в качестве this при выполнении функции mapFn

---------
    Array.from({length: 5}, (_, i) => i + 1) // [ 1, 2, 3, 4, 5 ]
    Array.from({length: 5}, (_, i) => i ) // [ 0, 1, 2, 3, 4 ]

// i+n n - точка отсчета 
// Изменить шаг `i` можно через `map`

    const numbers = 
        Array.from({length: 10 - 1}, (_, i) => i + 1 * 2).map(x => x * 2);

    console.log(numbers);
---------
  const calcNaturalNumbersBelowNum = (untilNum, ...multiples) => {
    return Array.from({length: untilNum - 1}, (_, i) => i + 1)
      .filter(num => multiples.some(multiple => num % multiple === 0));
  }
  // some() исп-ся как условие для фильтрации метода filter(), если true, то возвращает значение

Метод Array.from() создает новый экземпляр массива с неглубоким копированием из объекта. Первым аргументом метода Array.from() является итеративный объект, такой как массив, строка, набор или объект, подобный массиву (например, arguments или NodeList).
В этом конкретном примере код использует метод Array.from() для создания нового массива с длиной, равной значению переменной untilNum минус 1. Второй аргумент метода Array.from() - это функция сопоставления, которая используется для заполнения нового массива значениями. В этом случае функция сопоставления использует переменную i, которая передается функции в качестве второго аргумента, и добавляет к ней 1, поэтому новый массив будет заполнен последовательными числами, начинающимися с 1.
Символ подчеркивания "_" используется в качестве заполнителя для первого аргумента функции сопоставления, который в данном случае не нужен. Обычной практикой является использование подчеркивания в таких сценариях, чтобы указать, что аргумент не используется.

Метод Array.prototype.some() проверяет, проходит ли хотя бы один элемент в массиве проверку, реализованную предоставленной функцией. В этом случае предоставленная функция проверяет, делится ли текущий элемент (i + 1) на какое-либо из переданных кратных. Если это так, он вернет true для этого элемента, а some() вернет true для всего массива, указывая, что по крайней мере один элемент делится на переданные множители. Это позволяет нам отфильтровывать элементы, которые не делятся на переданные кратные, и оставлять только те, которые делятся хотя бы на одно из них.

---------------------------------------------------------
//// Webpack
---------------------------------------------------------
1) Инициализируем проект
    $ npm init -y

2) Установить Webpack
    $ npm install webpack webpack-cli --save-dev

3) Создаем webpack.config.js

    const path = require('path');

    module.exports = {
        mode: 'development', 
        entry: path.resolve(__dirname, 'src', 'index.js'),
        output: {
            filename: 'main.js',
            path: path.resolve(__dirname, 'dist'),
            clean: true,
        },
    };
// ./src/index.js (можно исп-ть и обычный способ пути)
// __dirname - корневая папка
// mode: 'development' - означает в разработке
// clean: true - папка сборки проекта будет очищаться при пересборке

---------
4) Устанавливаем HtmlWebpackPlugin
    $ npm install --save-dev html-webpack-plugin

Добавляем в начало webpack.config.js

    const HtmlWebpackPlugin = require('html-webpack-plugin')

И в module.exports = {}
    plugins: [
        new HtmlWebpackPlugin({
        template: path.resolve(__dirname, 'index.html'),
        })
    ]

---------
5) Устанавливаем babel-loader
    $ npm install -D babel-loader @babel/core @babel/preset-env webpack

Добавляем 
    module: {
        rules: [
        {
            test: /\.m?js$/,
            exclude: /node_modules/,
            use: {
            loader: 'babel-loader',
            options: {
                presets: [
                ['@babel/preset-env', { targets: "defaults" }]
                ],
                plugins: ['@babel/plugin-proposal-class-properties']
            }
            }
        }
        ]
    },

---------
6) Устанавливаем css-loader 
Guides --> Asset Management --> Loading CSS
    $ npm install --save-dev style-loader css-loader

Добавляем в rules
    {
        test: /\.css$/i,
        use: ['style-loader', 'css-loader'],
    },

Импортируем style.css в index.css

---------
7) Устанавливаем css-loader 
Guides --> Asset Management --> Loading Images

Добавляем в rules
    {
        test: /\.(png|svg|jpg|jpeg|gif)$/i,
        type: 'asset/resource',
    },

Импортируем картинку в index.js
    import Image from './Image.png';

И там же добавляем ее в img.src
    imgName.src = KEKS;

---------
8) Сбилдить проект
    $ npm run start

package.json --> scripts

    "scripts": {
        "start": "webpack"
    },

---------
9) Установка webpack-dev-server 
    $ npm install --save-dev webpack webpack-dev-server

Guides --> Development --> Using webpack-dev-server

Добавляем в webpack.config.js перед plugins
    devServer: {
        static: './dist', // Путь к паке с готовым проектом
        port: 8080,
        open: true,
    },

---------
10) Запустить сервер 
package.json --> scripts

    "start": "webpack serve",

0.1) Чтобы установить все пакеты которые уже прописаны package.json 
    $ npm install 
    $ npm i
---------------------------------------------------------
//// Object.fromEntries(Object.entries(obj).reverse()) -
перевернуть Объект
-------------------

    let obj = {a: 1, b: 2, c: 3};

    let reversedObj = Object.fromEntries(Object.entries(obj).reverse());

    console.log(reversedObj); // Output: {c: 3, b: 2, a: 1}

/// Object.entries() - преобразовать Объект в Массив пар ключ-значение
---------
/// Object.fromEntries() - преобразовать Массив в Объект

---------------------------------------------------------
//// Использование import, export, export default
---------------------------------------------------------
/// Экспортировать: 
---------
    export class App {
      run() {
        document.body.textContent = 'Jello!'
      }
    }
// Or 
    class App {
      run() {
        document.body.textContent = 'Jello!'
      }
    }
    export {
        App,
    }
// Or 
    export const PI = 3.14;
    function sayHello() {}
    class Car {}

    export { PI, sayHello, Car };
---------
/// Импортировать:
---------
    import { PI, sayHello, Car } from "./module.js";

    console.log(PI);

    sayHello();

    const car = new Car("BWM X5", 2020);
    car.showInfo();
---------
    import './file.js';

Будет выполнен код из файла file.js, однако нельзя будет использовать элементы из этого файла.
---------
Импортировать в другой файл элемент файла: 
    import { App, Element2 } from './src/modules/app.js'

Переименовать передаваемый элемент с помощью 'as'
    import { App as AppComponent, Element2 } from './src/modules/app.js'
---------
К HTML-файлам ES-модули подключаются с помощью тегов <script>, как и обычные скрипты, добавляется только атрибут type="module":
    <script type="module" src="index.js"></script>
-------------------
/// export default - может быть только один в файле
-------------------
export default - может быть только один в файле

    export default function sum(a, b) {
        return a + b;
    }
// Or
    function sum(a, b) {
        return a + b;
    }

    export default sum;

Экспортировать таким способом можно только один элемент модуля. То есть модуль может содержать только одну инструкцию export default.
Для экспортированных таким способом элементов импорт делается без фигурных скобок:

    import Any_Name from "./module.js";
    const result = Any_Name(2, 3);

Экспорт по умолчанию можно также смешивать с обычным именованным экспортом:
    export const PI = 3.14;
    export default function sum(a, b) {
        return a + b;
    }
Импорт:
    import sum, { PI } from "./module.js";

-------------------
/// import * as - импортировать все экспорт-е сущности из файла
-------------------
Синтаксис:
    import * as MyModule from "./module.js";

    console.log(MyModule.PI);

    MyModule.sayHello();

    const car = new MyModule.Car("BWM X5", 2020);
    car.showInfo();

---------------------------------------------------------
//// LocalStorage
---------------------------------------------------------
LocalStorage - работает только со String

To use localStorage to remember that a button was pressed, you can use the following code:

    const button = document.querySelector('button');

    button.addEventListener('click', function() {
        localStorage.setItem('buttonClicked', 'true');
    });

    if (localStorage.getItem('buttonClicked') === 'true') {
        // button was pressed, do something
    }
---------
    const myNumber = 42;
    
// записать el
    localStorage.setItem('number', myNumber.toString()) 
// получить el
    localStorage.getItem('number') 
// удалить el
    localStorage.removeItem('number') 
// очистить полностью storage
    localStorage.clear() 
---------
/// Работа с Объектами
---------
    const obj = {
        name: 'Max',
        age: 20,
    }
---------
// JSON.stringify(obj) - завернуть Объект в тип string
    person:"{"name":"Max","age":20}"
---------
// JSON.parse(raw) - преобразовать в нормальный Объект
    Object { name: "Max", age: 20 }
---------

    localStorage.setItem('person', obj); 
     // person:"[object Object]"

    localStorage.setItem('person', JSON.stringify(obj)) 
     // person:"{"name":"Max","age":20}"

    const raw = localStorage.getItem('person') // string
    console.log(raw.name); // undefined

    const person = JSON.parse(raw);
    console.log(person); 
     // Object { name: "Max", age: 20 }

    person.name = 'Vladilen'
    console.log(person); 
     // Object { name: "Vladilen", age: 20 }
-------------------
// Отличие localStorage от cookie
-------------------
localStorage больше по объему ~ 5MB
localStorage не уходит на сервер, в отличие от cookie
---------------------------------------------------------
//// Инициализация проекта через Git
---------------------------------------------------------
    $ git clone https://github.com/... - скачать репозиторий (находясь в папке)
    $ ls -a - выводит список файлов в папке + скрытые
    $ git config user.name 'your name'
------------------- 
!/// Отправка изменений
    $ git status - отображение статуса изменения файлов
   *$ git add . / $ git add [name1 name2 ...] - разрешает файлы для обработки их commit (промежуточная область - stage) 
   *$ git commit -m 'comment' - запись
    $ git log / $ git log --oneline - Отображение истории записи коммитов
   *$ git push [rep_link = origin] [branch_name] - Отправить на сервер
    // rep_link - можно узнать с помощью $ git remote -v или ввести origin
    // branch_name - $ git branch или ввести master
    $ git push origin master

/// Отмена изменений
    $ git reset name1 - удаление файла из буферной зоны для коммита
    $ git diff - история изменений файлов
    $ git reset --hard - откатывает все сделанные изменения во всех файлах (до прошлого коммита)

/// Файл .gitignore - хранит данные папок для игнорирования при добавлении в облако

---------
/// Ветки в Git
    $ git branch new_branch_name - создать ветку
    $ git checkout new_branch_name - переключение между ветками
      $ git push origin new_branch_name - отправить новую ветку и сохраненные в нее данные

    $ git branch -d branch_name - удалить ветку

// Перенос Ветки на Ветку
    На сайте вкладка pull requests --> Merge 
      В этой же вкладке можно добавить проверяющего "Reviewers"

// Перенос Изменений с облака
    $ git pull origin master - накатывает изменения из облака в локал 

// Слияние веток 
    $ git checkout master - переключение туда куда будем переносить
    $ git merge branch_name - переносит с указанной ветки на текущую
      $ git push origin branch_name - отправить изменения ветки 

---------------------------------------------------------
//// GitFlow
    1) Создать репозиторий и клонировать его на комп
        $ git clone url_git
    2) Создать ветку разработки develop от главной ветки (master , main)
        $ git branch develop
        $ git checkout develop
        $ git push origin develop
    3) От develop отходят ветки дробления задач 
    develop:
      - feature/main-page     (разрабатывается гл. страница)
      - feature/main-page     (разрабатывается стр. о компании)
      - feature/modals        (разрабатывается модальные окна)
      - feature/global-styles (разрабатываются глобальные стили)
    - Как только одна из веток была завершена, она объединятся (мержится) с главной develop
    4) Создание ветки release/0.1.0 от develop (когда близится дата релиза)
        $ git checkout develop -b release/0.1.0 
          (флаг -b говорит о переключении на созданную ветку)
    - В релизе допускается только исправление багов. Новые фичи запрещены.
    5) Когда ветка release/0.1.0 закончена (у нас есть что показать заказчику), то она мержится в develop и main, затем удалятся.
        $ git checkout main
        $ git merge release/0.1.0
        $ git push origin main

        $ git checkout develop
        $ git merge release/0.1.0
        $ git branch -d release/0.1.0
        $ git push origin develop
    6) Если в ветке main обнаружена ошибка, то создается hotfix-ветка 
        $ git checkout main
        $ git checkout -b hotfix/about-page-title-error
        // исправляем ошибку
        $ git commit -n 'add title on the about-page'
        $ git push origin hotfix/about-page-title-error
    7) Когда работа над hotfix-веткой завершается, то ее нужно мержить в develop и main
        $ git checkout main
        $ git merge hotfix/about-page-title-error
        $ git push origin main

        $ git checkout develop
        $ git merge hotfix/about-page-title-error
        $ git push origin develop

        $ git branch -d hotfix/about-page-title-error
        // git branch -d удалил локально, так же нужно удалить гитхабе 
---------------------------------------------------------
//// Доступ к репозиторию по SSH (для приватных репозиториев)
    1) Получаем SSH ссылку репозитория на сайте github
    2) Генерируем SSH-ключ для доступа по ссылке
        $ ssh-keygen -o
    - Указываем путь и название файла (называем как проект вместо id_rsa)
    - Вводим пароль для генерации 
    - Получаем наш ssh-key 
        $ cat указанный_путь_к_файлу
    - Переходим на github --> settings --> SSH and GPG keys --> New SSH Key
    - Вводим название ключа и вставляем наш ключ 
    3) Копируем наш репозиторий с помощью SSH и ключа 
        $ ssh-add указанный_путь_к_файлу (но без .pub в конце!)
          - Вводим пароль который установили при создании ключа
        $ git clone ssh_link
---------------------------------------------------------
//// React
---------------------------------------------------------
// React
    $ npx create-react-app my-app - Собрать React
    $ npm start - Запустить проект
---------
    Error: sh: 1: react-scripts: not found
Fix: 
    $ npm install react-scripts

-------------------
/// Bootstrap - библиотека, которая с помощью названия классов позволяет добавлять стили к нашим компонентам 

    $ npm install bootstrap

-------------------
index.js – входной в приложение JavaScript-файл, все начинается отсюда.

Здесь происходит монтирование корневого компонента в DOM-дерево, глобальное подключение сторонних библиотек и т.д.

    import React from "react";
    import ReactDOM from "react-dom/client";
    import App from "./App";
// Подключение Bootstrap из папки node_modules
    import "bootstrap/dist/css/bootstrap.css";

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<App />);

Перед подключением библиотек их необходимо установить.
Установка Bootstrap фиксированной версии 5.1.0:
    $ npm i bootstrap@5.1.0

-------------------
React-компонент можно создать как обычную JavaScript-функцию:
    const Post = () => {
        return <div>Post</div>;
    };
Компонент может принимать в себя данные - props и выводить их
    const Post = (props) => {
        return <div>Post: {props.title}</div>; // JSX синтаксис
    };
Такой синтаксис в JavaScript, похожий на HTML, называется JSX
---------
Вот так выглядит компонент Post после конвертации в обычный JavaScript:
    
    const Post = props => {
        return React.createElement("div", null, "Post: ", props.title);
    };

-------------------
// JSX - JS XML синтаксис для описания интерфейсов для React
-------------------
С помощью Babel преобразует JSX выражение в обычный JavaScript.

JSX выражение - интерпретация React.createElement('div')
JSX выражение в JS файле: <h1>Hello</h1> //(JSX)

    const Component = () => {
        return //(JSX)
    }
    reactDom.render(<Component />, document.getElementById('root'))

Все React-компоненты начинаются с заглавной буквы.
(если компонент называется с маленькой буквы, то React принимает его за DOM-тег)
---------
Эти React-элементы можно также записывать и в обычную переменную:
    const title = 'Junior Frontend Developer';
    const course = <h1>Course: {title}!</h1>;
Без JSX:
    const title = 'Junior Frontend Developer';
    const course = React.createElement("h1", null, "Course: ", title, "!");

-------------------
// React DOM - библиотека отвечает за рендеринг, отрисовку React-элементов в браузере
-------------------
React разработан таким образом, что он не зависит от браузера

Благодаря этому, на React мы можем разрабатывать не только браузерные интерфейсы, но и, к примеру, интерфейсы для мобильных приложений. Там уже вместо React DOM будет использоваться React Native. 

Таким образом React отвечает за работу с компонентами, React-элементами и тд, а за визуализацию в различных окружениях отвечают другие библиотеки (такие как React DOM).

---------
// Монтирование компонента в DOM-дерево:
---------
    import React from "react";
    import ReactDOM from "react-dom/client";

    const Post = (props) => {
        return <div>Post: {props.title}</div>;
    };

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<Post title={'Hello World'} />);

В элемент по селектору #root произойдет вставка <div>Post: Hello World</div>.

-------------------
/// Указание дочерних компонентов React
-------------------
Не сработает: 
Babel не поймет тк JSX выражение это React.createElement('div')
    
    const Counter = () => {
        return <h1>Counter</h1><button>+</button>;
    };

Если мы попытаемся вернуть из компонента несколько элементов, то мы получим ошибку: Выражения JSX должны иметь один родительский элемент.
---------
Сработает: (использование оберточной оболочки)
    const Counter = () => {
        return (
            <div>
                <h1>Counter</h1>
                <button>+</button>
            </div>
        );
    };
---------
Сработает: (Без использование оберточной оболочки)
    const Counter = () => {
        return (
            <React.Fragment>
                <h1>Counter</h1>
                <button>+</button>
            </React.Fragment>
        );
    };
---------
// Or 
---------
Сработает: (современный аналог)

    const Counter = () => {
        return (
            <>
                <h1>Counter</h1>
                <button>+</button>
            </>
        );
    };

Лучше чем <React.Fragment> (современный аналог):

-------------------
/// Вложения переменных, выражений, ветвлений, вызовов f() в React
-------------------
Переменные передаются в таких случаях как в JS через фигурные скобки {}, но только тут без наклонных кавычек ``

    const Counter = () => {
        const count = 2;
        return (
            <>
                <h1>{count + 2}</h1>
                <button>+</button>
            </>
        );
    };
---------
    export const Page = () => {
        const logoUrl = "";
        const siteName = "example.com";

        const getHeadline = () => {
            return logoUrl 
              ? (
                <img src={logoUrl} alt="logo"/>
            ) : (
                <div>{siteName}</div>
            );
        };

        return (
            <>
                <header>{getHeadline()}</header>
                <footer>подвал</footer>
            </>
        );
    };
---------
! // Good example:

    import React from "react";

    const Counter = () => {
        const count = 0;

        const formatCount = () => {
            return count === 0
                ? 'empty'
                : count;
        };

        const getBadgeClasses = () => {
            let classes = "badge m-2 ";
            classes += count === 0
                ? "bg-warning"
                : "bg-primary";
            return classes;
        };

        return (
            <>
                <span className={getBadgeClasses()}>
                    {formatCount()}
                </span>
                <button className="btn btn-primary btn-sm m-2">+</button>
            </>
        );
    };

    export default Counter;

---------
// className = '' - добавление класса HTML в JSX
---------
className используется для добавления класса в HTML с помощью JSX (используется вместо обычного class, тк оно уже зарезервировано)

    <span className="badge bg-primary">{formatCount()}</span>

-------------------
/// Обработка событий в React
-------------------
Референс функции это ссылка на функцию (без вызова)
---------
// `handle` - Обработчики событий должны начинаться с `handle`
---------
// `set` -  setФункция в useState() должна начинаться с `set`
---------

    <span className={getBadgeClasses()}>{formatCount()}</span>
    <button
        className="btn btn-primary btn-sm m-2"
        onClick={handleIncrement}
    >
        +
    </button>

Для обработки функции при передаче в EventListener, необходимо передавать референс функции, а не ее вызов

-------------------
/// useState() - хук для обновления данных (перерисовке DOM-el)
-------------------
// useState() - состоит из двух элементов. Возвращает кортеж (массив), в котором содержится значение состояния и функция для его изменения.

   I el - Хранит текущее состояние; (read)
   II el - Функция которая устанавливает данные массива состояния; (set)
           (Имя данной функции должно всегда начинаться с `set`)

 const [count, setCount] = useState(0);
     variable | function           (n) - variable_value / any_item 
                                                        (obj/arr/func etc)
---------
Для сообщения React о том что наше состояние изменилось, необходимо использовать функцию setCount()

    const Counter = () => {
        const [count, setCount] = useState(0);

        const handleIncrement = () => {
            setCount(count + 1);
        };
        ...
    };

useState() хранит значение нашей переменной "count" вне нашего компонента, в своем хранилище, поэтому переменная не перезаписывается в начальное значение при новом запуске.

---------
У useState() имеется система оптимизации дублирования событий.
useState() - асинхронная функция.

Например, если в коде, где-то дублируются одинаковые события, то он схлопнет их воедино.
    const handleIncrement = () => {
        setCount(count + 1);
        setCount(count + 1); // Итого будет count === 1
    };
---------
// Если мы вызываем setCount() 2 раза осознанно и его не надо схлопывать для оптимизации, то необходимо добавить callback. И передать в него текущее состояние переменной (чтобы операции шли именно с актуальным значением) 

Тк запрос на выполнение двух наших функций может быть асинхронным. 
  В связи с этим, не факт что первая переменная при вызове первого дубликата функции, обновиться к тому моменту как мы попробуем произвести с ним вторую операцию.

Поэтому передаем callback c параметром `prevState`.
    prevState - это текущее значение переменной, которое храниться в нашем состоянии.

    const handleIncrement = () => {
        setCount((prevState) => prevState + 1);
        setCount((prevState) => prevState + 1); // Итого будет count === 2
    };

---------
При наличии слушателя на элементе:
    1) Нам необходимо создать функцию handler которая будет возвращать результат того что должно произойти после клика.
      1.1) В handler-функции необходимо использовать callback(prevState), чтобы быть уверенным что используется именно текущее значение изменяющейся переменной.
    2) Для того чтобы значения обновлялись при event-е, нужно использовать Хук useState() для обновления данных.
    В который будет передаваться:
    [имя_переменной, setФункция] = сам_useState(начальное_значение)
    3) В handle-функцию необходимо передавать вместо обычной переменной
    setФункцию(new_value_after_event)

-------------------
/// Вывести данные массива в HTML через JSX
-------------------
// Для рендеринга el Массивов используется метод .map()

    <div>
        {array.map((arrayItem) => (
            <span>{arrayItem}</span>
        ))}
    </div>;
---------
Внутри JSX мы перебираем элементы массива и возвращаем нужные нам React-элементы.

В нашем примере выведем список пунктов меню:

! // Good example:

    const Navbar = () => {
        const [open, setOpen] = useState(false);
        const [menuItems, setMenuItems] = useState(["Главная", "Блог", "Контакты"]);

        const handleMenuClick = () => {
            setOpen((prevState) => !prevState);
        };

        return (
            <>
            <button
                className="btn btn-sm btm-primary"
                onClick={handleMenuClick}
            >
                Меню
            </button>
            {open && (
                <ul className="list-group">
                    {menuItems.map((item) => (
                        <li 
                            className="list-group-item" 
                            key={item}>
                            {item}
                        </li>
                    ))}
                </ul>
            )}
            </>
        );
    };

---------
Проблема в том, что в коде нет return-стейтмента. Код должен был выглядеть следующим образом:

    <tbody>
        {users.map((user) => {
            return (
                <tr key={user._id}>
                    <td>{user.name}</td>
                    <td>{user.qualities}</td>
                    <td>{user.profession}</td>
                    <td>{user.completedMeetings}</td>
                    <td>{user.rate}</td>
                </tr>;
            )
        })}
    </tbody>

Return - стейтмент является необходимым, чтобы React знал, что он должен возвращать.

-------------------
/// Найти и удалить el при клике по нему
-------------------
const Counter = () => {

    const [tags, setTags] = useState(["tag1", "tag2", "tag3"]);

    const handleTagChange = (id) => {
        setTags(prevState => prevState.filter(tag => tag !== id))
    };                         [tags].filter

    return (
        <>
            <ul>
                {tags.map((tag) => (
                <li
                    key={tag}
                    className="btn btn-primary btm-sm m-2"
                    onClick={() => handleTagChange(tag)}
                >
                    {tag}
                </li>
                ))}
            </ul>
        </>

---------
Передать обработчик событий :
    onClick={handleTagChange}

Передать параметры в обработчик событий:
    onClick={() => handleTagChange(tag)}
---------
Since with the construction onClick={handleTagChange(tag)}, `handleTagChange()` is called when the component is rendered, not when the button is clicked.

By using an arrow function () => handleTagChange(tag), you are creating a new function that takes no arguments and returns the result of calling handleTagChange with the tag argument. This allows you to delay the execution of handleTagChange until the onClick function is triggered.

Поэтому когда нет необходимости передавать аргументы функции, мы передаем  Референс функции в onClick. Тк при рендере Референс без вызова сам не сработает. 

---------
// Передача обновленных значений элементов
---------
Необходимо использовать методы setState() или useState() для передачи обновлений элементов в React, вместо прямого изменения DOM дерева. 

Тк React в свою очередь использует виртуальный DOM. 
Когда какой-то элемент изменяется, React обновляет виртуальный DOM, сравнивает изменения с предыдущим виртуальным DOM и обновляет фактический DOM только там, где это необходимо. 

Такой подход обеспечивает более высокую производительность и более эффективный механизм обновления, поскольку React обновит только те части DOM, которые действительно изменились, а не повторно отобразит все дерево компонентов. 

А прямое изменение элемента не приведет к повторному рендерингу, и React не будет знать об изменениях. Что приведет к снижению эффективности и к колхозному отношению к производительным технологиям.
---------

    const [tags, setTags] = useState(["tag1", "tag2", "tag3"]);

    const handleTagChange = (id) => {
        setTags(prevState => prevState.filter(tag => tag !== id))
    };

Для обновления элементов и их передачи, в нашем примере, необходимо использовать функцию setTags() - конструкцию метода UseState() 
и метод .filter() для передачи всех элементов которые подходят под описание элемента нажатия и исключая тот, который не удовлетворяет условиям. 
В итоге, новый список элементов передаем в функцию setTags() - конструкцию метода UseState(), в последствии чего нажатый элемент удаляется. 
---------
Так же необходимо использовать prevState (а не переменную которую передаем в конструкцию useState), когда имеем дело с изменением состояния переменной, в связи взаимодействия пользователя с UI!

    setTags(prevState => prevState.filter(tag => tag !== id))

It's important to use prevState because React state updates are asynchronous. If multiple updates are made to the state in quick succession, it's possible that some updates will be lost, as the state will be overwritten by the time the update function runs.

By using `prevState`, you ensure that your state updates correctly, regardless of when the update function runs.

So, in general, it's a good practice to always use `prevState` when updating state based on the previous state, to ensure that your state updates correctly and as expected.

-------------------
/// Условное ветвление Рендеринга
-------------------
// Ветвление в React допустимо двумя способами:

    - Тернарных выражений 
    {condition ? <Element1 /> : <Element2 />} 

    - Логических операций
    {condition && <Element1 />}

---------
import React, { useState } from "react";

const Navbar = () => {
  const [open, setOpen] = useState(false);
  const [menuItems, setMenuItems] = useState(["Главная", "Блог", "Контакты"]);

  const handleMenuClick = () => {
    setOpen((prevState) => !prevState);
  };

  const handleItemClick = (id) => {
    console.log(id);
  };

  // Создание пунктов меню
  const renderMenu = () => {
    return (
      // Если переменная open равна true то мы выводим пункты меню, иначе мы не выводим ничего.
      open && (
        <ul className="list-group">
          {menuItems.map((item) => (
            <li
              className="list-group-item"
              key={item}
              onClick={() => handleItemClick(item)}
            >
              {item}
            </li>
          ))}
        </ul>
      )
    );
  };

  return (
    <div>
      <button
        className="btn btn-sm btm-primary"
        onClick={handleMenuClick}
      >
        меню
      </button>
      {renderMenu()}
    </div>
  );
};

Будем выводить стрелочку вверх или вниз внутри кнопки ”меню” в зависимости от переменной open:

import React, { useState } from "react";

const Navbar = () => {
  const [open, setOpen] = useState(false);
  const [menuItems, setMenuItems] = useState(["Главная", "Блог", "Контакты"]);

  const handleMenuClick = () => { /* ... */ };
  const handleItemClick = (id) => { /* ... */ };
  const renderMenu = () => { /* ... */ };

  // Стрелочка вверх
  const arrowTop = (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="16"
      height="16"
      fill="currentColor"
      className="bi bi-arrow-up"
      viewBox="0 0 16 16"
    >
      <path
        fillRule="evenodd"
        d="M8 15a.5.5 0 0 0 .5-.5V2.707l3.146 3.147a.5.5 0 0 0 .708-.708l-4-4a.5.5 0 0 0-.708 0l-4 4a.5.5 0 1 0 .708.708L7.5 2.707V14.5a.5.5 0 0 0 .5.5z"
     />
    </svg>
  );

  // Стрелочка вниз
  const arrowDown = (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="16"
      height="16"
      fill="currentColor"
      className="bi bi-arrow-down"
      viewBox="0 0 16 16"
    >
      <path
        fillRule="evenodd"
        d="M8 1a.5.5 0 0 1 .5.5v11.793l3.146-3.147a.5.5 0 0 1 .708.708l-4 4a.5.5 0 0 1-.708 0l-4-4a.5.5 0 0 1 .708-.708L7.5 13.293V1.5A.5.5 0 0 1 8 1z"
      />
    </svg>
  );

  // Функция для отображения стрелочек
  const renderArrow = () => {
    return open ? arrowDown : arrowTop;
  };

  return (
    <div>
      <button
        className="btn btn-sm btm-primary"
        onClick={handleMenuClick}
      >
        {/*вызываем renderArrow() внутри кнопки*/}
        меню {renderArrow()}
      </button>
      {renderMenu()}
    </div>
  );
};
---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------